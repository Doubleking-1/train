<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>ç«è½¦ç¥¨è®°å½•ä¸åœ°å›¾ç¤ºä¾‹ï¼ˆå«æš—è‰²æ¨¡å¼ï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- å¼•å…¥é«˜å¾·åœ°å›¾ JS API æ ¸å¿ƒåº“ -->
  <script src="https://webapi.amap.com/maps?v=1.4.15&key=7e67c88a1371c1d3ac14e3afcfb81a74"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- å¼•å…¥SheetJSåº“ç”¨äºè§£æExcelæ–‡ä»¶ -->
  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <!-- å¼•å…¥Chart.jsåº“ç”¨äºç»˜åˆ¶å›¾è¡¨ -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* ä¸»é¢˜å˜é‡ */
    :root {
      --bg-color: #f8f9fa;
      --sidebar-bg: #ffffff;
      --text-color: #212529;
      --border-color: #dee2e6;
      --form-bg: #ffffff;
      --table-head-bg: #f2f2f2;
      --table-border: #dee2e6;
      --primary-color: #007bff;
      --input-bg: #fff;
      --input-border: #ced4da;
      --modal-bg: #ffffff;
      --btn-bg: #f0f0f0;
      --btn-text: #333;
      --btn-border: #ccc;
    }

    .dark {
      --bg-color: #121212;
      --sidebar-bg: #1e1e1e;
      --text-color: #e0e0e0;
      --border-color: #444;
      --form-bg: #2a2a2a;
      --table-head-bg: #2c2c2c;
      --table-border: #444;
      --primary-color: #66aaff;
      --input-bg: #333;
      --input-border: #555;
      --modal-bg: #2d2d2d;
      --btn-bg: #3a3a3a;
      --btn-text: #e0e0e0;
      --btn-border: #555;
    }

    /* å…¨å±€å¸ƒå±€ */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      font-size: 14px; /* Smaller base font size */
    }

    #sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 250px; /* ç¼©çª„ä¾§è¾¹æ ï¼Œä»300pxæ”¹ä¸º250px */
      background: var(--sidebar-bg);
      border-right: 1px solid var(--border-color);
      padding: 10px;
      overflow-y: auto;
      box-sizing: border-box;
      transition: background-color 0.3s, border-color 0.3s;
      z-index: 10;
    }

    #main {
      margin-left: 250px; /* è°ƒæ•´ä¸»åŒºåŸŸå·¦è¾¹è·ï¼Œä»300pxæ”¹ä¸º250px */
      padding: 15px;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    /* åˆ‡æ¢æŒ‰é’® */
    #themeToggle {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      background: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #themeToggle:hover {
      opacity: 0.9;
    }

    /* è¡¨å• */
    h2 {
      margin-top: 0;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 8px;
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    #modeIndicator {
      font-size: 12px;
      color: var(--primary-color);
      margin-bottom: 8px;
      font-weight: bold;
    }
    #form {
      background: var(--form-bg);
      padding: 10px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }
    .form-group {
      margin-bottom: 8px;
    }
    .form-group label {
      display: block;
      font-size: 12px;
      color: var(--text-color);
      margin-bottom: 4px;
    }

    .form-group input {
      width: 100%;
      padding: 6px 8px; /* Smaller padding */
      box-sizing: border-box;
      border: 1px solid var(--input-border);
      border-radius: 3px;
      font-size: 12px; /* Smaller font */
      background: var(--input-bg);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }
    #addRecordBtn {
      width: 100%;
      padding: 8px;
      background: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 8px;
    }

    /* å†å²è¡¨æ ¼ */
    #historyTable {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
      margin-bottom: 15px;
    }
    #historyTable th, #historyTable td {
      border: 1px solid var(--table-border);
      padding: 6px 8px; /* Smaller padding */
      font-size: 12px; /* Smaller font */
      white-space: nowrap;
      text-align: left;
    }
    #historyTable th {
      background: var(--table-head-bg);
      font-weight: 600;
    }
    #historyTable button {
      margin-right: 4px;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
      background-color: var(--btn-bg);
      color: var(--btn-text);
      border: 1px solid var(--btn-border);
      border-radius: 3px;
      transition: background-color 0.2s;
    }
    #historyTable button:hover {
        opacity: 0.8;
    }
    #historyTable button.gemini {
        background: transparent;
        border: none;
        padding: 2px;
    }
    .dark #addRecordBtn {
        color: #111; /* Dark text on primary color button */
    }


    /* åœ°å›¾å®¹å™¨ */
    #container {
      width: 100%;
      height: 80vh; /* Taller map */
      margin: 0;
      border-radius: 5px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      position: relative; /* ä¸ºå›¾ä¾‹å®šä½åšå‡†å¤‡ */
    }

    /* åœ°å›¾å³ä¸Šè§’æ ‡è®°åˆ‡æ¢æŒ‰é’®æ ·å¼ */
    #markerToggle {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1001;
      padding: 8px 12px;
      background: rgba(40, 167, 69, 0.9);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    #markerToggle:hover {
      background: rgba(40, 167, 69, 1);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    #markerToggle.hide-markers {
      background: rgba(220, 53, 69, 0.9);
    }

    #markerToggle.hide-markers:hover {
      background: rgba(220, 53, 69, 1);
    }

    .dark #markerToggle {
      background: rgba(40, 167, 69, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .dark #markerToggle.hide-markers {
      background: rgba(220, 53, 69, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* å¹´ä»½å›¾ä¾‹æ ·å¼ - è°ƒæ•´ä½ç½®é¿å…ä¸æŒ‰é’®é‡å  */
    #yearLegend {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: var(--modal-bg);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px;
      max-height: 300px;
      overflow-y: auto;
      min-width: 120px;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    #yearLegend h4 {
      margin: 0 0 6px 0;
      font-size: 12px;
      color: var(--text-color);
      text-align: center;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 4px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      font-size: 11px;
      color: var(--text-color);
    }

    .legend-color {
      width: 16px;
      height: 3px;
      margin-right: 6px;
      border-radius: 1px;
    }

    .legend-text {
      flex: 1;
    }

    /* Gemini Modal */
    #geminiModalOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
    }
    #geminiModal {
      background-color: var(--modal-bg);
      color: var(--text-color);
      padding: 20px;
      border-radius: 8px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }
    #geminiModal h3 {
        margin-top: 0;
        color: var(--primary-color);
    }
    #geminiModalClose {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        border: none;
        background: none;
        color: var(--text-color);
    }
    #geminiResult {
        white-space: pre-wrap; /* To respect newlines from API */
        line-height: 1.6;
    }
    .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: var(--primary-color);
        animation: spin 1s ease infinite;
        margin: 20px auto;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* æ€»ç»“é¢æ¿æ ·å¼ */
    #summaryPanel {
      margin-bottom: 15px;
      background: var(--form-bg);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      overflow: hidden;
    }

    .summary-tabs {
      display: flex;
      background: var(--table-head-bg);
      border-bottom: 1px solid var(--border-color);
    }

    .summary-tab {
      flex: 1;
      padding: 10px 15px;
      background: transparent;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
    }

    .summary-tab:hover {
      background: var(--primary-color);
      color: white;
    }

    .summary-tab.active {
      background: var(--primary-color);
      color: white;
      border-bottom-color: #0056b3;
    }

    .summary-content {
      padding: 15px;
      display: none;
    }

    .summary-content.active {
      display: block;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 15px;
    }

    .stat-card {
      background: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 12px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-color);
      opacity: 0.8;
    }

    .year-selector {
      margin-bottom: 15px;
      text-align: center;
    }

    .year-selector select {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--input-bg);
      color: var(--text-color);
      font-size: 14px;
      cursor: pointer;
    }

    /* å›¾è¡¨å®¹å™¨æ ·å¼ */
    #chartsPanel {
      margin-top: 20px;
      background: var(--form-bg);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 20px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .chart-container {
      background: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 15px;
      height: 300px;
      position: relative;
    }

    .chart-title {
      text-align: center;
      font-size: 14px;
      font-weight: bold;
      color: var(--text-color);
      margin-bottom: 10px;
    }

    @media (max-width: 768px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>

  <!-- Sidebar: Form + Theme Toggle -->
  <div id="sidebar">
    <button id="themeToggle">åˆ‡æ¢æš—è‰²æ¨¡å¼</button>
    
    <h2>ç«è½¦ç¥¨è®°å½•</h2
    
    <!-- æ•°æ®å¯¼å…¥å¯¼å‡ºæŒ‰é’® -->
    <div style="margin-bottom: 15px; display: flex; gap: 5px;">
      <button id="importCsvBtn" style="flex: 1; padding: 8px; font-size: 12px; background: #fd7e14; color: white; border: none; border-radius: 3px; cursor: pointer;">ğŸ“„ å¯¼å…¥CSV</button>
      <button id="exportCsvBtn" style="flex: 1; padding: 8px; font-size: 12px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">ğŸ’¾ å¯¼å‡ºCSV</button>
    </div>
    
    <input type="file" id="importCsvFile" accept=".csv" style="display: none;">
    
    <div id="modeIndicator">å½“å‰æ“ä½œï¼šæ·»åŠ </div>
    <div id="form">
      <div class="form-group"><label>åºå·</label><input id="seq" type="number" readonly></div>
      <div class="form-group"><label>æ—¥æœŸ</label><input id="date" type="date"></div>
      <div class="form-group"><label>æ—¶é—´</label><input id="time" type="time"></div>
      <div class="form-group"><label>æ—¶é•¿ (hh:mm)</label><input id="duration" placeholder="ä¾‹å¦‚ 07:54"></div>
      <div class="form-group"><label>è½¦æ¬¡</label><input id="trainNo"></div>
      <div class="form-group"><label>èµ·ç‚¹ç«™</label><input id="startStation"></div>
      <div class="form-group"><label>èµ·ç‚¹åŸå¸‚</label><input id="startCity"></div>
      <div class="form-group"><label>ç»ˆç‚¹ç«™</label><input id="endStation"></div>
      <div class="form-group"><label>ç»ˆç‚¹åŸå¸‚</label><input id="endCity"></div>
      <div class="form-group"><label>åº§å¸­</label><input id="seatClass"></div>
      <div class="form-group"><label>è½¦å‹å·</label><input id="trainType"></div>
      <div class="form-group"><label>é“è·¯å±€</label><input id="bureau"></div>
      <div class="form-group"><label>è´¹ç”¨ (RMB)</label><input id="cost" type="number" step="0.01"></div>
      <div class="form-group"><label>é‡Œç¨‹ (km)</label><input id="distance" type="number"></div>
      <div class="form-group"><label>RMB/km</label><input id="pricePerKm" readonly></div>
      <div class="form-group"><label>å¤‡æ³¨</label><input id="notes"></div>
      <button id="addRecordBtn">æ·»åŠ è®°å½•</button>
    </div>
  </div>

  <!-- Main Area: Summary + Map + Table -->
  <div id="main">
    <!-- æ€»ç»“é¢æ¿ -->
    <div id="summaryPanel">
      <div class="summary-tabs">
        <button class="summary-tab active" data-tab="all">å†å²æ€»ç»“</button>
        <button class="summary-tab" data-tab="yearly">å¹´åº¦æ€»ç»“</button>
      </div>

      <!-- å†å²æ€»ç»“å†…å®¹ -->
      <div id="allSummary" class="summary-content active">
        <div class="stats-grid" id="allStatsGrid">
          <!-- ç»Ÿè®¡å¡ç‰‡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
      </div>

      <!-- å¹´åº¦æ€»ç»“å†…å®¹ -->
      <div id="yearlySummary" class="summary-content">
        <div class="year-selector">
          <select id="yearSelect">
            <option value="">è¯·é€‰æ‹©å¹´ä»½</option>
          </select>
        </div>
        <div class="stats-grid" id="yearlyStatsGrid">
          <!-- ç»Ÿè®¡å¡ç‰‡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
      </div>
    </div>

    <!-- å›¾è¡¨é¢æ¿ -->
    <div id="chartsPanel">
      <div class="charts-grid">
        <div class="chart-container">
          <div class="chart-title">å¹´åº¦ä¹˜è½¦æ¬¡æ•°</div>
          <canvas id="tripsChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">å¹´åº¦é‡Œç¨‹ (å…¬é‡Œ)</div>
          <canvas id="distanceChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">å¹´åº¦èŠ±è´¹ (å…ƒ)</div>
          <canvas id="costChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">å¹´åº¦ä¹˜è½¦æ—¶é•¿ (å°æ—¶)</div>
          <canvas id="durationChart"></canvas>
        </div>
      </div>
    </div>

    <div id="container">
      <!-- æ ‡è®°åˆ‡æ¢æŒ‰é’®ç§»åˆ°åœ°å›¾å³ä¸Šè§’ -->
      <button id="markerToggle">æ˜¾ç¤ºåœ°ç‚¹æ ‡è®°</button>
      
      <!-- å¹´ä»½å›¾ä¾‹ -->
      <div id="yearLegend">
        <h4>å¹´ä»½å›¾ä¾‹</h4>
        <div id="legendContent"></div>
      </div>
    </div>
    
    <table id="historyTable">
      <thead>
        <tr>
          <th>#</th><th>æ—¥æœŸ</th><th>æ—¶é—´</th><th>æ—¶é•¿</th><th>è½¦æ¬¡</th><th>èµ·ç‚¹ç«™</th><th>èµ·ç‚¹åŸå¸‚</th><th>ç»ˆç‚¹ç«™</th><th>ç»ˆç‚¹åŸå¸‚</th><th>åº§å¸­</th><th>è½¦å‹å·</th><th>é“è·¯å±€</th><th>è´¹ç”¨</th><th>é‡Œç¨‹</th><th>RMB/km</th><th>å¤‡æ³¨</th><th>æ“ä½œ</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Gemini Modal -->
  <div id="geminiModalOverlay">
      <div id="geminiModal">
          <button id="geminiModalClose">&times;</button>
          <h3 id="geminiModalTitle"></h3>
          <div id="geminiResult">
              <div class="spinner"></div>
          </div>
      </div>
  </div>

  <script>
    // --- Global Variables & Constants ---
    const REST_KEY = '0a6359d1470048a89ba86cfb5f53f2e9'; // Please use your own key
    const STORAGE_KEY = 'trainRecords';
    const GEOCODE_CACHE_KEY = 'geocodeCache'; // æ–°å¢ï¼šåœ°ç†ç¼–ç ç¼“å­˜é”®
    const LIGHT_MAP_STYLE = 'amap://styles/normal';
    const DARK_MAP_STYLE = 'amap://styles/dark';
    let records = [];
    let insertionTarget = null;
    let currentMode = 'add'; // 'add' | 'modify' | 'insert'
    const counts = {}; // For offsetting duplicate paths
    let map; // Declare map variable here
    
    // æ–°å¢ï¼šåœ°ç†ç¼–ç ç¼“å­˜
    let geocodeCache = {};

    // æ–°å¢ï¼šæ ‡è®°æ˜¾ç¤ºçŠ¶æ€
    let showMarkers = false;

    // --- UI Elements ---
    const themeToggle = document.getElementById('themeToggle');
    const modeIndicator = document.getElementById('modeIndicator');
    const addBtn = document.getElementById('addRecordBtn');
    const tbody = document.querySelector('#historyTable tbody');
    // Form inputs
    const seqInput = document.getElementById('seq');
    const costInput = document.getElementById('cost');
    const distanceInput = document.getElementById('distance');
    const pricePerKmInput = document.getElementById('pricePerKm');
    const endStationInput = document.getElementById('endStation');

    // Gemini Feature Elements
    const geminiModalOverlay = document.getElementById('geminiModalOverlay');
    const geminiModalClose = document.getElementById('geminiModalClose');
    const geminiModalTitle = document.getElementById('geminiModalTitle');
    const geminiResult = document.getElementById('geminiResult');
    const markerToggle = document.getElementById('markerToggle');
    const yearLegend = document.getElementById('yearLegend');
    const legendContent = document.getElementById('legendContent');
    const startCityInput = document.getElementById('startCity');
    const endCityInput = document.getElementById('endCity');
    const yearSelect = document.getElementById('yearSelect');

    // å›¾è¡¨å®ä¾‹
    let tripsChart, distanceChart, costChart, durationChart;

    // --- Functions ---

    // Update map theme based on body class
    function updateMapTheme() {
      const isDark = document.body.classList.contains('dark');
      if (map) { // Ensure map is initialized
        map.setMapStyle(isDark ? DARK_MAP_STYLE : LIGHT_MAP_STYLE);
      }
      // æ›´æ–°å›¾è¡¨ä¸»é¢˜
      updateChartsTheme();
    }

    // Calculate RMB/km
    function updatePricePerKm() {
      const c = parseFloat(costInput.value) || 0;
      const d = parseFloat(distanceInput.value) || 0;
      pricePerKmInput.value = d > 0 ? (c / d).toFixed(4) : '';
    }

    // Save records to localStorage
    function saveRecords() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(records));
    }

    // è®¡ç®—æ€»æ—¶é•¿ï¼ˆå°†æ—¶é•¿å­—ç¬¦ä¸²è½¬æ¢ä¸ºåˆ†é’Ÿæ•°ï¼‰
    function parseDurationToMinutes(duration) {
      if (!duration) return 0;
      const match = duration.match(/(\d{1,2}):(\d{1,2})/);
      if (match) {
        const hours = parseInt(match[1]) || 0;
        const minutes = parseInt(match[2]) || 0;
        return hours * 60 + minutes;
      }
      return 0;
    }

    // å°†åˆ†é’Ÿæ•°è½¬æ¢ä¸ºæ—¶é•¿å­—ç¬¦ä¸²
    function formatMinutesToDuration(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours}å°æ—¶${mins}åˆ†é’Ÿ`;
    }

    // æ›´æ–°å†å²æ€»ç»“
    function updateAllTimeSummary() {
      const container = document.getElementById('allStatsGrid');
      
      if (records.length === 0) {
        container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999;">æš‚æ— æ•°æ®</div>';
        return;
      }

      // ç»Ÿè®¡æ•°æ®
      const totalTrips = records.length;
      const totalCost = records.reduce((sum, r) => sum + (r.cost || 0), 0);
      const totalDistance = records.reduce((sum, r) => sum + (r.distance || 0), 0);
      const totalMinutes = records.reduce((sum, r) => sum + parseDurationToMinutes(r.duration), 0);
      
      // ç»Ÿè®¡åŸå¸‚ï¼ˆåªçœ‹èµ·ç‚¹åŸå¸‚å’Œç»ˆç‚¹åŸå¸‚ï¼‰
      const cities = new Set();
      records.forEach(r => {
        if (r.startCity && r.startCity.trim()) {
          cities.add(r.startCity.trim());
        }
        if (r.endCity && r.endCity.trim()) {
          cities.add(r.endCity.trim());
        }
      });

      // ç»Ÿè®¡å¹´ä»½
      const years = new Set();
      records.forEach(r => {
        if (r.date) {
          years.add(r.date.substring(0, 4));
        }
      });

      // æ‰¾å‡ºæœ€è¿œå’Œæœ€è¿‘çš„è¡Œç¨‹
      const longestTrip = records.reduce((a, r) => (r.distance || 0) > (a.distance || 0) ? r : a, records[0]);
      const shortestTrip = records.reduce((a, r) => (r.distance || 0) < (a.distance || 0) ? r : a, records[0]);

      // æ‰¾å‡ºæœ€è´µå’Œæœ€ä¾¿å®œçš„è¡Œç¨‹
      const mostExpensive = records.reduce((a, r) => (r.cost || 0) > (a.cost || 0) ? r : a, records[0]);
      const cheapest = records.reduce((a, r) => (r.cost || 0) < (a.cost || 0) ? r : a, records[0]);

      // å¹³å‡å€¼
      const avgCost = totalTrips > 0 ? (totalCost / totalTrips).toFixed(2) : 0;
      const avgDistance = totalTrips > 0 ? (totalDistance / totalTrips).toFixed(1) : 0;
      const avgDuration = totalTrips > 0 ? formatMinutesToDuration(Math.round(totalMinutes / totalTrips)) : '0åˆ†é’Ÿ';

      // ç”Ÿæˆç»Ÿè®¡å¡ç‰‡
      container.innerHTML = `
        <div class="stat-card">
          <div class="stat-value">${totalTrips}</div>
          <div class="stat-label">æ€»è¡Œç¨‹æ•°</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">Â¥${totalCost.toFixed(2)}</div>
          <div class="stat-label">æ€»èŠ±è´¹</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${totalDistance.toLocaleString()}</div>
          <div class="stat-label">æ€»é‡Œç¨‹ (å…¬é‡Œ)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatMinutesToDuration(totalMinutes)}</div>
          <div class="stat-label">æ€»ä¹˜è½¦æ—¶é•¿</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${cities.size}</div>
          <div class="stat-label">åˆ°è®¿åŸå¸‚æ•°</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${years.size}</div>
          <div class="stat-label">è·¨è¶Šå¹´ä»½</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">Â¥${avgCost}</div>
          <div class="stat-label">å¹³å‡ç¥¨ä»·</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDistance}å…¬é‡Œ</div>
          <div class="stat-label">å¹³å‡é‡Œç¨‹</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDuration}</div>
          <div class="stat-label">å¹³å‡æ—¶é•¿</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${longestTrip.startCity || longestTrip.startStation} â†’ ${longestTrip.endCity || longestTrip.endStation}</div>
          <div class="stat-label">æœ€è¿œè¡Œç¨‹ (${longestTrip.distance}å…¬é‡Œ)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostExpensive.startCity || mostExpensive.startStation} â†’ ${mostExpensive.endCity || mostExpensive.endStation}</div>
          <div class="stat-label">æœ€è´µè¡Œç¨‹ (Â¥${mostExpensive.cost})</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${(totalDistance / 40075).toFixed(2)}</div>
          <div class="stat-label">ç»•åœ°çƒåœˆæ•°</div>
        </div>
      `;
    }

    // æ›´æ–°å¹´ä»½é€‰æ‹©å™¨
    function updateYearSelect() {
      const years = [...new Set(records.map(r => {
        if (r.date) {
          return r.date.substring(0, 4);
        }
        return null;
      }).filter(y => y))].sort((a, b) => parseInt(b) - parseInt(a));

      yearSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å¹´ä»½</option>';
      years.forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = `${year}å¹´`;
        yearSelect.appendChild(option);
      });
    }

    // æ›´æ–°å¹´åº¦æ€»ç»“
    function updateYearlySummary(year) {
      const container = document.getElementById('yearlyStatsGrid');
      
      if (!year) {
        container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999;">è¯·é€‰æ‹©å¹´ä»½</div>';
        return;
      }

      const yearRecords = records.filter(r => r.date && r.date.substring(0, 4) === year);
      
      if (yearRecords.length === 0) {
        container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999;">è¯¥å¹´ä»½æš‚æ— æ•°æ®</div>';
        return;
      }

      // ç»Ÿè®¡æ•°æ®
      const totalTrips = yearRecords.length;
      const totalCost = yearRecords.reduce((sum, r) => sum + (r.cost || 0), 0);
      const totalDistance = yearRecords.reduce((sum, r) => sum + (r.distance || 0), 0);
      const totalMinutes = yearRecords.reduce((sum, r) => sum + parseDurationToMinutes(r.duration), 0);
      
      // ç»Ÿè®¡åŸå¸‚ï¼ˆåªçœ‹èµ·ç‚¹åŸå¸‚å’Œç»ˆç‚¹åŸå¸‚ï¼‰
      const cities = new Set();
      yearRecords.forEach(r => {
        if (r.startCity && r.startCity.trim()) {
          cities.add(r.startCity.trim());
        }
        if (r.endCity && r.endCity.trim()) {
          cities.add(r.endCity.trim());
        }
      });

      // ç»Ÿè®¡é“è·¯å±€ï¼ˆå»é‡ï¼‰
      const bureaus = new Set();
      yearRecords.forEach(r => {
        if (r.bureau && r.bureau.trim()) {
          bureaus.add(r.bureau.trim());
        }
      });

      // ç»Ÿè®¡æœˆä»½åˆ†å¸ƒ
      const monthStats = Array.from({ length: 12 }, () => ({ trips: 0, cost: 0, distance: 0 }));
      yearRecords.forEach(r => {
        const month = new Date(r.date).getMonth();
        monthStats[month].trips++;
        monthStats[month].cost += r.cost || 0;
        monthStats[month].distance += r.distance || 0;
      });

      const mostActiveMonth = monthStats.reduce((max, current, index) => 
        current.trips > max.trips ? { ...current, month: index + 1 } : max, 
        { trips: 0, month: 1 }
      );

      // æ‰¾å‡ºæœ€å¸¸å»çš„è·¯çº¿
      const routeCounts = {};
      yearRecords.forEach(r => {
        const route = `${r.startCity || r.startStation} â†’ ${r.endCity || r.endStation}`;
        routeCounts[route] = (routeCounts[route] || 0) + 1;
      });
      const mostFrequentRoute = Object.entries(routeCounts).reduce((a, v) => 
        v[1] > a[1] ? v : a, ['', 0]
      );

      // æ‰¾å‡ºæœ€å¸¸ä¹˜åçš„é“è·¯å±€
      const bureauCounts = {};
      yearRecords.forEach(r => {
        if (r.bureau && r.bureau.trim()) {
          bureauCounts[r.bureau.trim()] = (bureauCounts[r.bureau.trim()] || 0) + 1;
        }
      });
      const mostFrequentBureau = Object.entries(bureauCounts).reduce((a, v) => 
        v[1] > a[1] ? v : a, ['', 0]
      );

      // å¹³å‡å€¼
      const avgCost = (totalCost / totalTrips).toFixed(2);
      const avgDistance = (totalDistance / totalTrips).toFixed(1);
      const avgDuration = formatMinutesToDuration(Math.round(totalMinutes / totalTrips));

      // è®¡ç®—å æ€»ä½“æ¯”ä¾‹
      const allTotalCost = records.reduce((sum, r) => sum + (r.cost || 0), 0);
      const allTotalDistance = records.reduce((sum, r) => sum + (r.distance || 0), 0);

      // ç”Ÿæˆç»Ÿè®¡å¡ç‰‡
      container.innerHTML = `
        <div class="stat-card">
          <div class="stat-value">${totalTrips}</div>
          <div class="stat-label">${year}å¹´æ€»è¡Œç¨‹</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">Â¥${totalCost.toFixed(2)}</div>
          <div class="stat-label">${year}å¹´æ€»èŠ±è´¹</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${totalDistance.toLocaleString()}</div>
          <div class="stat-label">${year}å¹´æ€»é‡Œç¨‹ (å…¬é‡Œ)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatMinutesToDuration(totalMinutes)}</div>
          <div class="stat-label">${year}å¹´æ€»æ—¶é•¿</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${cities.size}</div>
          <div class="stat-label">åˆ°è®¿åŸå¸‚æ•°</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${bureaus.size}</div>
          <div class="stat-label">æ¶‰åŠé“è·¯å±€</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostActiveMonth.month}æœˆ</div>
          <div class="stat-label">æœ€æ´»è·ƒæœˆä»½ (${mostActiveMonth.trips}æ¬¡)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">Â¥${avgCost}</div>
          <div class="stat-label">å¹³å‡ç¥¨ä»·</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDistance}å…¬é‡Œ</div>
          <div class="stat-label">å¹³å‡é‡Œç¨‹</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDuration}</div>
          <div class="stat-label">å¹³å‡æ—¶é•¿</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostFrequentRoute[0]}</div>
          <div class="stat-label">æœ€å¸¸è·¯çº¿ (${mostFrequentRoute[1]}æ¬¡)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostFrequentBureau[0] || 'æ— æ•°æ®'}</div>
          <div class="stat-label">æœ€å¸¸é“è·¯å±€ (${mostFrequentBureau[1] || 0}æ¬¡)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${allTotalCost > 0 ? (totalCost / allTotalCost * 100).toFixed(1) : 0}%</div>
          <div class="stat-label">å æ€»èŠ±è´¹æ¯”ä¾‹</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${allTotalDistance > 0 ? (totalDistance / allTotalDistance * 100).toFixed(1) : 0}%</div>
          <div class="stat-label">å æ€»é‡Œç¨‹æ¯”ä¾‹</div>
        </div>
      `;
    }

    // æ ¹æ®å¹´ä»½ç”Ÿæˆé¢œè‰²çš„å‡½æ•°ï¼ˆæå–ä¸ºç‹¬ç«‹å‡½æ•°ä»¥ä¾¿å¤ç”¨ï¼‰
    function getYearColor(year) {
        const colors = [
            '#FF0000', // çº¢è‰²
            '#00FF00', // ç»¿è‰²  
            '#0000FF', // è“è‰²
            '#FFD700', // é‡‘è‰²
            '#FF69B4', // ç²‰è‰²
            '#00FFFF', // é’è‰²
            '#FF4500', // æ©™çº¢è‰²
            '#9370DB', // ç´«è‰²
            '#32CD32', // é…¸æ©™ç»¿
            '#FF1493', // æ·±ç²‰è‰²
            '#00CED1', // æš—ç»¿æ¾çŸ³è‰²
            '#FF6347', // ç•ªèŒ„è‰²
            '#4169E1', // çš‡å®¶è“
            '#DC143C', // æ·±çº¢è‰²
            '#228B22', // æ£®æ—ç»¿
            '#B22222', // ç«ç –è‰²
            '#4B0082', // é›è“
            '#DAA520', // é‡‘æ†è‰²
            '#8A2BE2', // è“ç´«è‰²
            '#FF8C00'  // æš—æ©™è‰²
        ];
        
        const yearNum = parseInt(year) || new Date().getFullYear();
        const colorIndex = yearNum % colors.length;
        return colors[colorIndex];
    }

    // æ›´æ–°å¹´ä»½å›¾ä¾‹ - ä»æ—¥æœŸæå–å¹´ä»½
    function updateYearLegend() {
        // ç»Ÿè®¡æ¯å¹´çš„è®°å½•æ•°é‡
        const yearStats = {};
        records.forEach(record => {
            const year = record.date ? record.date.substring(0, 4) : new Date().getFullYear().toString();
            yearStats[year] = (yearStats[year] || 0) + 1;
        });

        // æ¸…ç©ºå›¾ä¾‹å†…å®¹
        legendContent.innerHTML = '';

        // æŒ‰å¹´ä»½æ’åº
        const sortedYears = Object.keys(yearStats).sort((a, b) => parseInt(a) - parseInt(b));

        if (sortedYears.length === 0) {
            legendContent.innerHTML = '<div style="font-size: 10px; color: #999; text-align: center;">æš‚æ— æ•°æ®</div>';
            return;
        }

        // ç”Ÿæˆå›¾ä¾‹é¡¹
        sortedYears.forEach(year => {
            const count = yearStats[year];
            const color = getYearColor(year);
            
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `
                <div class="legend-color" style="background-color: ${color};"></div>
                <div class="legend-text">${year}å¹´ (${count}æ¬¡)</div>
            `;
            legendContent.appendChild(legendItem);
        });
    }

    // åˆ›å»ºå¹´åº¦ç»Ÿè®¡å›¾è¡¨
    function createYearlyCharts() {
      if (records.length === 0) return;

      // æŒ‰å¹´ä»½ç»Ÿè®¡æ•°æ®
      const yearlyData = {};
      records.forEach(record => {
        const year = record.date ? record.date.substring(0, 4) : new Date().getFullYear().toString();
        if (!yearlyData[year]) {
          yearlyData[year] = {
            trips: 0,
            distance: 0,
            cost: 0,
            duration: 0 // ä»¥åˆ†é’Ÿä¸ºå•ä½
          };
        }
        yearlyData[year].trips++;
        yearlyData[year].distance += record.distance || 0;
        yearlyData[year].cost += record.cost || 0;
        yearlyData[year].duration += parseDurationToMinutes(record.duration);
      });

      // æ’åºå¹´ä»½
      const years = Object.keys(yearlyData).sort((a, b) => parseInt(a) - parseInt(b));
      const trips = years.map(year => yearlyData[year].trips);
      const distances = years.map(year => yearlyData[year].distance);
      const costs = years.map(year => yearlyData[year].cost);
      const durations = years.map(year => Math.round(yearlyData[year].duration / 60)); // è½¬æ¢ä¸ºå°æ—¶

      // è·å–å½“å‰ä¸»é¢˜çš„æ–‡å­—é¢œè‰²
      const isDark = document.body.classList.contains('dark');
      const textColor = isDark ? '#e0e0e0' : '#212529';

      // é€šç”¨å›¾è¡¨é…ç½®
      const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          }
        },
        scales: {
          x: {
            grid: {
              display: false // ç§»é™¤ç½‘æ ¼çº¿
            },
            ticks: {
              color: textColor,
              padding: 10 // å¢åŠ æ ‡ç­¾ä¸åæ ‡è½´çš„è·ç¦»
            }
          },
          y: {
            beginAtZero: true,
            grid: {
              display: false // ç§»é™¤ç½‘æ ¼çº¿
            },
            ticks: {
              color: textColor
            }
          }
        }
      };

      // é”€æ¯å·²å­˜åœ¨çš„å›¾è¡¨
      if (tripsChart) tripsChart.destroy();
      if (distanceChart) distanceChart.destroy();
      if (costChart) costChart.destroy();
      if (durationChart) durationChart.destroy();

      // ä¹˜è½¦æ¬¡æ•°å›¾è¡¨
      const tripsCtx = document.getElementById('tripsChart').getContext('2d');
      tripsChart = new Chart(tripsCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: trips,
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });

      // é‡Œç¨‹å›¾è¡¨
      const distanceCtx = document.getElementById('distanceChart').getContext('2d');
      distanceChart = new Chart(distanceCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: distances,
            backgroundColor: 'rgba(255, 99, 132, 0.6)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });

      // èŠ±è´¹å›¾è¡¨
      const costCtx = document.getElementById('costChart').getContext('2d');
      costChart = new Chart(costCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: costs,
            backgroundColor: 'rgba(255, 206, 86, 0.6)',
            borderColor: 'rgba(255, 206, 86, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });

      // æ—¶é•¿å›¾è¡¨
      const durationCtx = document.getElementById('durationChart').getContext('2d');
      durationChart = new Chart(durationCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: durations,
            backgroundColor: 'rgba(75, 192, 192, 0.6)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });
    }

    // æ›´æ–°ä¸»é¢˜é¢œè‰²æ—¶é‡æ–°åˆ›å»ºå›¾è¡¨
    function updateChartsTheme() {
      if (tripsChart || distanceChart || costChart || durationChart) {
        // å»¶è¿Ÿæ‰§è¡Œä»¥ç¡®ä¿CSSå˜é‡å·²æ›´æ–°
        setTimeout(() => {
          createYearlyCharts();
        }, 100);
      }
    }

    // æ›´æ–°æ‰€æœ‰æ€»ç»“é¢æ¿
    function updateSummaryPanels() {
      updateAllTimeSummary();
      updateYearSelect();
      const selectedYear = yearSelect.value;
      if (selectedYear) {
        updateYearlySummary(selectedYear);
      }
      
      // æ›´æ–°å›¾è¡¨
      createYearlyCharts();
    }

    // Save geocode results to localStorage
    function saveGeocodeCache() {
      try {
        localStorage.setItem(GEOCODE_CACHE_KEY, JSON.stringify(geocodeCache));
      } catch (error) {
        console.error('ä¿å­˜åœ°ç†ç¼–ç ç¼“å­˜å¤±è´¥:', error);
      }
    }

    // Load geocode results from localStorage
    function loadGeocodeCache() {
      try {
        const cached = localStorage.getItem(GEOCODE_CACHE_KEY);
        if (cached) {
          geocodeCache = JSON.parse(cached);
          console.log(`å·²åŠ è½½ ${Object.keys(geocodeCache).length} ä¸ªç¼“å­˜çš„åœ°ç†ç¼–ç ç»“æœ`);
        }
      } catch (error) {
        console.error('åŠ è½½åœ°ç†ç¼–ç ç¼“å­˜å¤±è´¥:', error);
        geocodeCache = {};
      }
    }

    // Update sequence numbers in the table
    function updateSequenceNumbers() {
      Array.from(tbody.children).forEach((tr, i) => {
        tr.cells[0].innerText = i + 1;
      });
    }

    // Set the current operation mode ('add', 'modify', 'insert')
    function setMode(mode, targetTr = null) {
      currentMode = mode;
      insertionTarget = targetTr; // Used for 'insert' and 'modify' modes
      
      if (mode === 'modify') {
        modeIndicator.textContent = 'å½“å‰æ“ä½œï¼šä¿®æ”¹';
        addBtn.textContent = 'ä¿å­˜ä¿®æ”¹';
      } else if (mode === 'insert') {
        modeIndicator.textContent = 'å½“å‰æ“ä½œï¼šæ’å…¥';
        addBtn.textContent = 'åœ¨æ­¤è¡Œåæ’å…¥';
      } else { // 'add' mode
        modeIndicator.textContent = 'å½“å‰æ“ä½œï¼šæ·»åŠ ';
        addBtn.textContent = 'æ·»åŠ è®°å½•';
        insertionTarget = null;
      }
      updateSeqInput();
    }

    // Update the sequence input field based on the mode
    function updateSeqInput() {
      if (currentMode === 'insert' && insertionTarget) {
        const idx = Array.from(tbody.children).indexOf(insertionTarget);
        seqInput.value = idx + 2;
      } else if (currentMode === 'modify') {
        // seqInput is already populated
      } else { // 'add' mode
        seqInput.value = tbody.children.length + 1;
      }
    }

    // Clear the input form
    function clearForm() {
      ['date','time','duration','trainNo','startStation','startCity','endStation','endCity','seatClass','trainType','bureau','cost','distance','notes']
        .forEach(id => document.getElementById(id).value = '');
      updatePricePerKm();
      updateSeqInput();
    }

    // Attach event listeners to buttons in a table row
    function attachRowEvents(tr) {
      // Delete button
      tr.querySelector('.delete').addEventListener('click', (e) => {
        e.stopPropagation();
        tr._overlays?.forEach(o => o.setMap(null));
        tr.remove();
        updateSequenceNumbers();
        if (currentMode !== 'add') {
          clearForm();
          setMode('add');
        }
        syncRecordsFromTable();
      });

      // Modify button
      tr.querySelector('.modify').addEventListener('click', (e) => {
        e.stopPropagation();
        const c = tr.cells;
        seqInput.value = c[0].innerText;
        document.getElementById('date').value = c[1].innerText;
        document.getElementById('time').value = c[2].innerText;
        document.getElementById('duration').value = c[3].innerText;
        document.getElementById('trainNo').value = c[4].innerText;
        document.getElementById('startStation').value = c[5].innerText;
        startCityInput.value = c[6].innerText;
        document.getElementById('endStation').value = c[7].innerText;
        endCityInput.value = c[8].innerText;
        document.getElementById('seatClass').value = c[9].innerText;
        document.getElementById('trainType').value = c[10].innerText;
        document.getElementById('bureau').value = c[11].innerText;
        costInput.value = c[12].innerText;
        distanceInput.value = c[13].innerText;
        pricePerKmInput.value = c[14].innerText;
        document.getElementById('notes').value = c[15].innerText;
        setMode('modify', tr);
      });
      
      // Insert button
      tr.querySelector('.insert').addEventListener('click', (e) => {
        e.stopPropagation();
        clearForm();
        setMode('insert', tr);
      });

      // Gemini button in table row
      tr.querySelector('.gemini').addEventListener('click', (e) => {
        e.stopPropagation();
        const city = tr.cells[8].innerText; // ä½¿ç”¨ç»ˆç‚¹åŸå¸‚
        if (city) {
            getTravelGuide(city);
        } else {
            alert("è¯¥è®°å½•æ²¡æœ‰ç»ˆç‚¹åŸå¸‚ä¿¡æ¯ã€‚");
        }
      });
    }

    // ä¼˜åŒ–åœ°ç†ç¼–ç å‡½æ•°ï¼Œä½¿ç”¨åŸå¸‚+ç«™ç‚¹çš„ç»„åˆ
    function geocode(station, city) {
      if (!station) return Promise.reject(new Error('Station is empty'));
      
      // æ„å»ºæœç´¢åœ°å€ï¼šåŸå¸‚+ç«™ç‚¹+"ç«™"
      let searchAddr = '';
      if (city && city.trim()) {
        searchAddr = city.trim() + station.trim();
        if (!searchAddr.endsWith('ç«™')) {
          searchAddr += 'ç«™';
        }
      } else {
        searchAddr = station.endsWith('ç«™') ? station : station + 'ç«™';
      }
      
      // ä½¿ç”¨ç»„åˆåœ°å€ä½œä¸ºç¼“å­˜é”®
      const cacheKey = searchAddr;
      
      // æ£€æŸ¥ç¼“å­˜
      if (geocodeCache[cacheKey]) {
        console.log(`ä½¿ç”¨ç¼“å­˜çš„åœ°ç†ç¼–ç ç»“æœ: ${cacheKey}`);
        return Promise.resolve(geocodeCache[cacheKey]);
      }
      
      const url = new URL('https://restapi.amap.com/v3/geocode/geo');
      url.search = new URLSearchParams({ key: REST_KEY, address: searchAddr, city: 'å…¨å›½' }).toString();
      
      console.log(`åœ°ç†ç¼–ç æœç´¢: "${station}" + "${city}" -> "${searchAddr}"`);
      
      return fetch(url)
        .then(r => r.json())
        .then(data => {
          if (data.status === '1' && data.geocodes.length) {
            const coords = data.geocodes[0].location.split(',').map(Number);
            // ä¿å­˜åˆ°ç¼“å­˜
            geocodeCache[cacheKey] = coords;
            saveGeocodeCache();
            console.log(`åœ°ç†ç¼–ç æˆåŠŸ: ${searchAddr} -> [${coords[0]}, ${coords[1]}]`);
            return coords;
          }
          throw new Error(`Geocoding failed for ${searchAddr}: ${data.info}`);
        })
        .catch(error => {
          console.error(`åœ°ç†ç¼–ç å¤±è´¥ for ${searchAddr}:`, error);
          throw error;
        });
    }

    // Draw the path on the map for a given record - ä½¿ç”¨æ–°çš„åœ°ç†ç¼–ç æ–¹å¼
    async function drawPath(tr, recordData) {
        try {
            // ä½¿ç”¨åŸå¸‚+ç«™ç‚¹çš„ç»„åˆè¿›è¡Œåœ°ç†ç¼–ç 
            const startCoords = await geocode(recordData.startStation, recordData.startCity);
            const endCoords = await geocode(recordData.endStation, recordData.endCity);
            
            // ä¸ºèµ·ç»ˆç‚¹ç›¸åŒçš„è·¯çº¿åˆ›å»ºä¸€ä¸ªå”¯ä¸€çš„é”®ï¼Œå¹¶è®¡æ•°
            const key = [recordData.startStation, recordData.endStation].sort().join('â†’');
            counts[key] = (counts[key] || 0) + 1;
            const pathIndex = counts[key] - 1;

            // æ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦åˆ›å»ºæ ‡è®°ç‚¹
            let marker1, marker2;
            if (showMarkers) {
                marker1 = new AMap.Marker({ position: startCoords, map });
                marker2 = new AMap.Marker({ position: endCoords, map });
            }
            
            // è·å–å½“å‰è®°å½•å¹´ä»½å¯¹åº”çš„é¢œè‰² - ä»æ—¥æœŸæå–å¹´ä»½
            const year = recordData.date ? recordData.date.substring(0, 4) : new Date().getFullYear().toString();
            const strokeColor = getYearColor(year);
            
            // ç”Ÿæˆè´å¡å°”å¼§çº¿
            function generateArc(p1, p2, idx = 0) {
              const [x1, y1] = p1, [x2, y2] = p2;
              const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
              const dx = x2 - x1, dy = y2 - y1, len = Math.hypot(dx, dy);
              let ux = -dy / len, uy = dx / len;
              
              // å‡å°åŸºç¡€å¼§åº¦ç³»æ•°ï¼Œä»0.35å‡å°åˆ°0.15
              const base = 0.15 * len;
              const factor = base * (1 + idx * 0.15);
              if(idx % 2) { ux = -ux; uy = -uy; }
              
              // ä½¿ç”¨æ›´å¤šçš„æ§åˆ¶ç‚¹
              const controlPoints = [];
              
              // ç”Ÿæˆ5ä¸ªæ§åˆ¶ç‚¹ï¼Œæ²¿ç€å‚ç›´æ–¹å‘é€‚åº¦åç§»
              for (let i = 0; i < 5; i++) {
                const t = (i + 1) / 6; // æ§åˆ¶ç‚¹åœ¨çº¿æ®µä¸Šçš„ç›¸å¯¹ä½ç½® (1/6, 2/6, ..., 5/6)
                // ä½¿ç”¨æ›´åŠ å¹³æ»‘çš„æ­£å¼¦å‡½æ•°ï¼Œå‡å°å¹…åº¦
                const cx = x1 + dx * t + ux * factor * Math.sin(Math.PI * t) * 0.8;
                const cy = y1 + dy * t + uy * factor * Math.sin(Math.PI * t) * 0.8;
                controlPoints.push([cx, cy]);
              }
              
              const seg = 120; // å¢åŠ æ®µæ•°ï¼Œä»80å¢åŠ åˆ°120ï¼Œä½¿æ›²çº¿æ›´å¹³æ»‘
              const path = [];
              
              // å…­é˜¶è´å¡å°”æ›²çº¿ (èµ·ç‚¹ + 5ä¸ªæ§åˆ¶ç‚¹ + ç»ˆç‚¹)
              for(let i = 0; i <= seg; i++) {
                const t = i / seg;
                
                // ä½¿ç”¨å…­é˜¶è´å¡å°”æ›²çº¿å…¬å¼
                // å‚è€ƒDe Casteljauç®—æ³•å®ç°é«˜é˜¶è´å¡å°”æ›²çº¿
                let point = [0, 0];
                let binomialCoef = 1;
                
                // èµ·ç‚¹
                point[0] += Math.pow(1-t, 6) * x1;
                point[1] += Math.pow(1-t, 6) * y1;
                
                // 5ä¸ªæ§åˆ¶ç‚¹
                for (let j = 0; j < 5; j++) {
                  binomialCoef = binomialCoef * (6-j) / (j+1); // è®¡ç®—äºŒé¡¹å¼ç³»æ•° C(6,j+1)
                  const factor = binomialCoef * Math.pow(t, j+1) * Math.pow(1-t, 5-j);
                  point[0] += factor * controlPoints[j][0];
                  point[1] += factor * controlPoints[j][1];
                }
                
                // ç»ˆç‚¹
                point[0] += Math.pow(t, 6) * x2;
                point[1] += Math.pow(t, 6) * y2;
                
                path.push(point);
              }
              
              return path;
            }
            
            // ç”Ÿæˆè·¯å¾„å¹¶åˆ›å»ºæŠ˜çº¿
            const path = generateArc(startCoords, endCoords, pathIndex);
            const polyline = new AMap.Polyline({
                path: path,
                isOutline: false,
                strokeColor: strokeColor, // ä½¿ç”¨å¹´ä»½å¯¹åº”çš„é¢œè‰²
                strokeWeight: 2,
                strokeOpacity: 0.9,
                strokeStyle: 'solid'
            });
            
            map.add(polyline);
            
            // å­˜å‚¨è¦†ç›–ç‰©ï¼Œæ ¹æ®æ˜¯å¦æ˜¾ç¤ºæ ‡è®°å†³å®šå­˜å‚¨å†…å®¹
            if (showMarkers) {
                tr._overlays = [marker1, marker2, polyline];
            } else {
                tr._overlays = [polyline];
            }
        } catch (error) {
            console.error('ç»˜åˆ¶è·¯å¾„å¤±è´¥:', error);
        }
    }

    // Add a record to the table and draw it on the map
    function addRecordToTable(recordData, insertAfterTr = null) {
      const tr = document.createElement('tr');
      const rpk = recordData.distance > 0 ? (recordData.cost / recordData.distance).toFixed(4) : '';
      tr.innerHTML = `
        <td></td> <!-- Seq # updated later -->
        <td>${recordData.date}</td>
        <td>${recordData.time}</td>
        <td>${recordData.duration}</td>
        <td>${recordData.trainNo}</td>
        <td>${recordData.startStation}</td>
        <td>${recordData.startCity}</td>
        <td>${recordData.endStation}</td>
        <td>${recordData.endCity}</td>
        <td>${recordData.seatClass}</td>
        <td>${recordData.trainType}</td>
        <td>${recordData.bureau}</td>
        <td>${recordData.cost.toFixed(2)}</td>
        <td>${recordData.distance}</td>
        <td>${rpk}</td>
        <td>${recordData.notes}</td>
        <td>
          <button class="gemini" title="è·å–ç›®çš„åœ°æ—…æ¸¸æ”»ç•¥">âœ¨</button>
          <button class="modify">ä¿®æ”¹</button>
          <button class="insert">æ’å…¥</button>
          <button class="delete">åˆ é™¤</button>
        </td>
      `;
      tbody.appendChild(tr);
      attachRowEvents(tr);
      // å®æ—¶ç»˜åˆ¶è·¯å¾„ï¼Œæ— è®ºåœ°å›¾æ˜¯å¦å®Œå…¨åŠ è½½
      drawPath(tr, recordData);
      
      // æ›´æ–°å›¾ä¾‹
      updateYearLegend();
      
      return tr;
    }

    // æ–°å¢ï¼šåˆ‡æ¢æ ‡è®°æ˜¾ç¤ºçŠ¶æ€
    function toggleMarkers() {
        showMarkers = !showMarkers;
        markerToggle.textContent = showMarkers ? 'éšè—åœ°ç‚¹æ ‡è®°' : 'æ˜¾ç¤ºåœ°ç‚¹æ ‡è®°';
        
        // æ›´æ–°æŒ‰é’®æ ·å¼
        if (showMarkers) {
            markerToggle.classList.add('hide-markers');
        } else {
            markerToggle.classList.remove('hide-markers');
        }
        
        // ä¿å­˜è®¾ç½®åˆ°localStorage
        localStorage.setItem('showMarkers', showMarkers);
        
        // é‡æ–°ç»˜åˆ¶æ‰€æœ‰è·¯å¾„
        redrawAllPaths();
    }

    // æ–°å¢ï¼šé‡æ–°ç»˜åˆ¶æ‰€æœ‰è·¯å¾„
    async function redrawAllPaths() {
        // æ¸…é™¤ç°æœ‰çš„æ‰€æœ‰è¦†ç›–ç‰©
        Array.from(tbody.children).forEach(tr => {
            tr._overlays?.forEach(o => o.setMap(null));
            tr._overlays = [];
        });
        
        // æ¸…ç©ºè®¡æ•°å™¨
        Object.keys(counts).forEach(key => delete counts[key]);
        
        // é‡æ–°ç»˜åˆ¶æ‰€æœ‰è·¯å¾„
        const allRows = Array.from(tbody.children);
        for (let i = 0; i < allRows.length; i++) {
            const tr = allRows[i];
            const rec = records[i];
            if (rec && rec.startStation && rec.endStation) {
                try {
                    await drawPath(tr, rec);
                    // åªæœ‰åœ¨éœ€è¦APIè°ƒç”¨æ—¶æ‰å»¶è¿Ÿ
                    const needsApi = !geocodeCache[rec.startStation] || !geocodeCache[rec.endStation];
                    if (needsApi) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (error) {
                    console.error('é‡ç»˜è·¯å¾„å¤±è´¥:', error);
                }
            }
        }

        // æ›´æ–°å›¾ä¾‹
        updateYearLegend();
    }

    // --- Gemini API Function ---
    async function getTravelGuide(city) {
        geminiModalTitle.textContent = `${city} æ—…æ¸¸æ”»ç•¥ âœ¨`;
        geminiResult.innerHTML = '<div class="spinner"></div>';
        geminiModalOverlay.style.display = 'flex';

        const prompt = `ä¸ºä¸­å›½çš„"${city}"å¸‚å†™ä¸€ä»½ç®€æ´çš„æ—…æ¸¸æ”»ç•¥ï¼Œé£æ ¼æ´»æ³¼æœ‰è¶£ã€‚è¯·ä½¿ç”¨Markdownæ ¼å¼ï¼ŒåŒ…å«ï¼š
1. ä¸‰ä¸ªæœ€å€¼å¾—å»çš„æ™¯ç‚¹ï¼Œå¹¶é™„ä¸Šä¸€å¥å¸å¼•äººçš„æè¿°ã€‚
2. ä¸‰æ ·å¿…åƒçš„å½“åœ°ç‰¹è‰²ç¾é£Ÿã€‚
3. ä¸€æ¡ç»™æ¸¸å®¢çš„å°è´´å£«ã€‚`;
        
        let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
        const payload = { contents: chatHistory };
        const apiKey = "AIzaSyAoOKoSnfj4KceHi7xyzL_Xww-7iY3gAGI";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.statusText}`);
            }

            const result = await response.json();
            
            if (result.candidates && result.candidates.length > 0) {
                const markdownText = result.candidates[0].content.parts[0].text;
                // ä½¿ç”¨ marked.js æ¸²æŸ“ Markdown
                geminiResult.innerHTML = marked.parse(markdownText);
            } else {
                throw new Error("æœªèƒ½ä»APIè·å–æœ‰æ•ˆå›å¤ã€‚");
            }
        } catch (error) {
            console.error("Gemini API call failed:", error);
            geminiResult.textContent = `è·å–æ”»ç•¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚\né”™è¯¯: ${error.message}`;
        }
    }
    
    // --- Initial Load & Event Listeners ---

    // Set initial theme
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.body.classList.toggle('dark', savedTheme === 'dark');
    themeToggle.textContent = savedTheme === 'dark' ? 'åˆ‡æ¢æµ…è‰²æ¨¡å¼' : 'åˆ‡æ¢æš—è‰²æ¨¡å¼';

    // åŠ è½½æ ‡è®°æ˜¾ç¤ºè®¾ç½®
    showMarkers = localStorage.getItem('showMarkers') === 'true';
    markerToggle.textContent = showMarkers ? 'éšè—åœ°ç‚¹æ ‡è®°' : 'æ˜¾ç¤ºåœ°ç‚¹æ ‡è®°';
    
    // åˆå§‹åŒ–æŒ‰é’®æ ·å¼
    if (showMarkers) {
        markerToggle.classList.add('hide-markers');
    } else {
        markerToggle.classList.remove('hide-markers');
    }

    // Theme toggle listener
    themeToggle.addEventListener('click', () => {
      const isDark = document.body.classList.toggle('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      themeToggle.textContent = isDark ? 'åˆ‡æ¢æµ…è‰²æ¨¡å¼' : 'åˆ‡æ¢æš—è‰²æ¨¡å¼';
      updateMapTheme();
    });

    // æ ‡è®°åˆ‡æ¢ç›‘å¬å™¨
    markerToggle.addEventListener('click', toggleMarkers);

    // æ€»ç»“é¢æ¿æ ‡ç­¾åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
    document.querySelectorAll('.summary-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // ç§»é™¤æ‰€æœ‰æ´»åŠ¨çŠ¶æ€
        document.querySelectorAll('.summary-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.summary-content').forEach(c => c.classList.remove('active'));
        
        // æ·»åŠ æ´»åŠ¨çŠ¶æ€
        tab.classList.add('active');
        const tabName = tab.dataset.tab;
        document.getElementById(tabName + 'Summary').classList.add('active');
      });
    });

    // å¹´ä»½é€‰æ‹©å™¨äº‹ä»¶ç›‘å¬å™¨
    yearSelect.addEventListener('change', (e) => {
      updateYearlySummary(e.target.value);
    });

    // Price calculation listeners
    costInput.addEventListener('input', updatePricePerKm);
    distanceInput.addEventListener('input', updatePricePerKm);

    // CSVå¯¼å‡ºäº‹ä»¶ç›‘å¬ - ä¿®å¤ï¼šæ·»åŠ ç¼ºå¤±çš„äº‹ä»¶ç›‘å¬å™¨
    document.getElementById('exportCsvBtn').addEventListener('click', exportToCsv);

    // CSVå¯¼å…¥äº‹ä»¶ç›‘å¬
    document.getElementById('importCsvBtn').addEventListener('click', () => {
      document.getElementById('importCsvFile').click();
    });
    
    document.getElementById('importCsvFile').addEventListener('change', e => {
      if (e.target.files.length > 0) {
        importCsv(e.target.files[0]);
        e.target.value = ''; // é‡ç½®æ–‡ä»¶é€‰æ‹©å™¨
      }
    });
    
    // Main form submission logic
    addBtn.addEventListener('click', () => {
      const recordData = {
          date: document.getElementById('date').value,
          time: document.getElementById('time').value,
          duration: document.getElementById('duration').value,
          trainNo: document.getElementById('trainNo').value.trim(),
          startStation: document.getElementById('startStation').value.trim(),
          startCity: startCityInput.value.trim(),
          endStation: document.getElementById('endStation').value.trim(),
          endCity: endCityInput.value.trim(),
          seatClass: document.getElementById('seatClass').value.trim(),
          trainType: document.getElementById('trainType').value.trim(),
          bureau: document.getElementById('bureau').value.trim(),
          cost: parseFloat(costInput.value) || 0,
          distance: parseFloat(distanceInput.value) || 0,
          notes: document.getElementById('notes').value.trim()
      };

      if (!recordData.startStation || !recordData.endStation) {
          alert("èµ·ç‚¹å’Œç»ˆç‚¹ç«™ä¸èƒ½ä¸ºç©ºï¼");
          return;
      }
      
      let newRow;
      if (currentMode === 'modify' && insertionTarget) {
          insertionTarget._overlays?.forEach(o => o.setMap(null));
          const insertBefore = insertionTarget.nextSibling;
          insertionTarget.remove();
          newRow = addRecordToTable(recordData);
          if (insertBefore) {
            tbody.insertBefore(newRow, insertBefore);
          } else {
            tbody.appendChild(newRow);
          }
      } else if (currentMode === 'insert' && insertionTarget) {
          addRecordToTable(recordData, insertionTarget);
      } else { // 'add' mode
          addRecordToTable(recordData);
      }

      updateSequenceNumbers();
      syncRecordsFromTable(); // Save all changes
      clearForm();
      setMode('add');
    });

    // Modal close listeners
    geminiModalClose.addEventListener('click', () => {
        geminiModalOverlay.style.display = 'none';
    });
    geminiModalOverlay.addEventListener('click', (e) => {
        if (e.target === geminiModalOverlay) {
            geminiModalOverlay.style.display = 'none';
        }
    });

    // æ–°å¢ï¼šCSVå¯¼å…¥åŠŸèƒ½
    function importCsv(file) {
      if (!file) return;
      
      const reader = new FileReader();
      
      reader.onload = function(e) {
        try {
          const csvText = e.target.result;
          const lines = csvText.split('\n');
          
          if (lines.length <= 1) {
            throw new Error('CSVæ–‡ä»¶æ— æ•°æ®æˆ–æ ¼å¼é”™è¯¯');
          }
          
          // è§£æCSVå¤´éƒ¨
          const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
          console.log('CSVè¡¨å¤´:', headers);
          
          // è§£æCSVæ•°æ®
          const csvData = [];
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const values = parseCsvLine(line);
            if (values.length === headers.length) {
              const rowData = {};
              headers.forEach((header, index) => {
                rowData[header] = values[index];
              });
              csvData.push(rowData);
            }
          }
          
          console.log('CSVæ•°æ®é¢„è§ˆ:', csvData);
          
          // è§£æCSVæ•°æ®ä¸ºåº”ç”¨æ ¼å¼
          const newRecords = parseCsvToRecords(csvData);
          
          if (newRecords.length === 0) {
            throw new Error('æ— æ³•è§£æCSVæ•°æ®ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
          }
          
          // è¯¢é—®ç”¨æˆ·å¦‚ä½•å¤„ç†æ•°æ®
          const replace = confirm(
            `æˆåŠŸè§£æ ${newRecords.length} æ¡è®°å½•\n\n` +
            `ç‚¹å‡»"ç¡®å®š"æ›¿æ¢æ‰€æœ‰ç°æœ‰æ•°æ®\n` +
            `ç‚¹å‡»"å–æ¶ˆ"æ·»åŠ åˆ°ç°æœ‰æ•°æ®`
          );
          
          if (replace) {
            records = newRecords;
          } else {
            records = [...records, ...newRecords];
          }
          
          saveRecords();
          alert(`${replace ? 'æ›¿æ¢' : 'æ·»åŠ '}äº† ${newRecords.length} æ¡è®°å½•ï¼Œé¡µé¢å°†é‡æ–°åŠ è½½`);
          location.reload();
          
        } catch (error) {
          console.error('CSVå¯¼å…¥å¤±è´¥:', error);
          alert('CSVå¯¼å…¥å¤±è´¥: ' + error.message);
        }
      };
      
      reader.onerror = function() {
        alert('è¯»å–CSVæ–‡ä»¶å¤±è´¥');
      };
      
      reader.readAsText(file, 'UTF-8');
    }

    // è§£æCSVè¡Œï¼Œå¤„ç†å¼•å·åŒ…å›´çš„å­—æ®µ
    function parseCsvLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      
      result.push(current.trim());
      return result;
    }

    // è§£æCSVæ•°æ®ä¸ºè®°å½•æ ¼å¼
    function parseCsvToRecords(csvData) {
      const newRecords = [];
      
      // å­—æ®µæ˜ å°„
      const fieldMap = {
        seq: 'åºå·',
        date: 'æ—¶é—´',
        time: 'æ—¶åˆ»', 
        duration: 'æ—¶é•¿',
        trainNo: 'è½¦æ¬¡',
        startStation: 'èµ·ç‚¹',
        startCity: 'èµ·ç‚¹åŸå¸‚',
        endStation: 'ç»ˆç‚¹',
        endCity: 'ç»ˆç‚¹åŸå¸‚',
        seatClass: 'åå¸­',
        trainType: 'è½¦å‹å·',
        bureau: 'é“è·¯å±€',
        cost: 'è´¹ç”¨(RMB)',
        distance: 'é‡Œç¨‹(km)',
        pricePerKm: 'RMB/km',
        notes: 'å¤‡æ³¨'
      };
      
      for (const row of csvData) {
        try {
          // å¤„ç†æ—¥æœŸæ ¼å¼
          let date = '';
          if (row[fieldMap.date]) {
            const dateStr = String(row[fieldMap.date]);
            const match = dateStr.match(/(\d{4})[\.\-\/]?(\d{1,2})[\.\-\/]?(\d{1,2})/);
            if (match) {
              const [, y, m, d] = match;
              date = `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
            }
          }
          
          // å¤„ç†æ—¶é—´æ ¼å¼
          let time = '';
          if (row[fieldMap.time]) {
            const timeStr = String(row[fieldMap.time]).trim();
            const match = timeStr.match(/(\d{1,2})[\ï¼š\:\.]\s*(\d{1,2})/);
            if (match) {
              const [, h, m] = match;
              time = `${h.padStart(2, '0')}:${m.padStart(2, '0')}`;
            }
          }
          
          // å¤„ç†æ—¶é•¿æ ¼å¼
          let duration = '';
          if (row[fieldMap.duration]) {
            const durationStr = String(row[fieldMap.duration]);
            const match = durationStr.match(/(\d{1,2})[\ï¼š\:](\d{1,2})/);
            if (match) {
              const [, h, m] = match;
              duration = `${h.padStart(2, '0')}:${m.padStart(2, '0')}`;
            }
          }
          
          const record = {
            date: date,
            time: time,
            duration: duration,
            trainNo: String(row[fieldMap.trainNo] || ''),
            startStation: String(row[fieldMap.startStation] || ''),
            startCity: String(row[fieldMap.startCity] || ''),
            endStation: String(row[fieldMap.endStation] || ''),
            endCity: String(row[fieldMap.endCity] || ''),
            seatClass: String(row[fieldMap.seatClass] || ''),
            trainType: String(row[fieldMap.trainType] || ''),
            bureau: String(row[fieldMap.bureau] || ''),
            cost: parseFloat(row[fieldMap.cost]) || 0,
            distance: parseFloat(row[fieldMap.distance]) || 0,
            notes: String(row[fieldMap.notes] || '')
          };
          
          // éªŒè¯å¿…è¦å­—æ®µ
          if (!record.startStation || !record.endStation) {
            console.warn('è·³è¿‡æ— æ•ˆè¡Œï¼Œç¼ºå°‘èµ·ç‚¹æˆ–ç»ˆç‚¹:', row);
            continue;
          }
          
          newRecords.push(record);
          
        } catch (error) {
          console.warn('è§£æCSVè¡Œæ•°æ®å¤±è´¥:', row, error);
        }
      }
      
      return newRecords;
    }

    // CSVå¯¼å…¥äº‹ä»¶ç›‘å¬
    document.getElementById('importCsvBtn').addEventListener('click', () => {
      document.getElementById('importCsvFile').click();
    });
    
    document.getElementById('importCsvFile').addEventListener('change', e => {
      if (e.target.files.length > 0) {
        importCsv(e.target.files[0]);
        e.target.value = ''; // é‡ç½®æ–‡ä»¶é€‰æ‹©å™¨
      }
    });

    // æ–°å¢ï¼šCSVå¯¼å‡ºåŠŸèƒ½
    function exportToCsv() {
      try {
        if (records.length === 0) {
          alert('æ²¡æœ‰æ•°æ®å¯ä»¥å¯¼å‡ºï¼');
          return;
        }

        // CSVè¡¨å¤´
        const headers = [
          'åºå·', 'æ—¶é—´', 'æ—¶åˆ»', 'æ—¶é•¿', 'è½¦æ¬¡', 'èµ·ç‚¹', 'èµ·ç‚¹åŸå¸‚', 
          'ç»ˆç‚¹', 'ç»ˆç‚¹åŸå¸‚', 'åå¸­', 'è½¦å‹å·', 'é“è·¯å±€', 
          'è´¹ç”¨(RMB)', 'é‡Œç¨‹(km)', 'RMB/km', 'å¤‡æ³¨'
        ];

        // æ„å»ºCSVå†…å®¹
        const csvContent = [];
        
        // æ·»åŠ è¡¨å¤´
        csvContent.push(headers.join(','));
        
        // æ·»åŠ æ•°æ®è¡Œ
        records.forEach((record, index) => {
          const pricePerKm = record.distance > 0 ? (record.cost / record.distance).toFixed(4) : '';
          const row = [
            index + 1, // åºå·
            record.date || '',
            record.time || '',
            record.duration || '',
            record.trainNo || '',
            record.startStation || '',
            record.startCity || '',
            record.endStation || '',
            record.endCity || '',
            record.seatClass || '',
            record.trainType || '',
            record.bureau || '',
            (record.cost || 0).toFixed(2),
            record.distance || 0,
            pricePerKm,
            record.notes || ''
          ];
          
          // å¤„ç†åŒ…å«é€—å·çš„å­—æ®µï¼Œç”¨å¼•å·åŒ…å›´
          const escapedRow = row.map(field => {
            const fieldStr = String(field);
            if (fieldStr.includes(',') || fieldStr.includes('"') || fieldStr.includes('\n')) {
              return '"' + fieldStr.replace(/"/g, '""') + '"';
            }
            return fieldStr;
          });
          
          csvContent.push(escapedRow.join(','));
        });

        // åˆ›å»ºBlobå¯¹è±¡
        const csvString = csvContent.join('\n');
        const blob = new Blob(['\uFEFF' + csvString], { type: 'text/csv;charset=utf-8;' });

        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        
        // ç”Ÿæˆæ–‡ä»¶åï¼ˆåŒ…å«å½“å‰æ—¥æœŸï¼‰
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 10);
        link.setAttribute('download', `ç«è½¦ç¥¨è®°å½•_${dateStr}.csv`);
        
        // è§¦å‘ä¸‹è½½
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert(`æˆåŠŸå¯¼å‡º ${records.length} æ¡è®°å½•åˆ°CSVæ–‡ä»¶ï¼`);
        
      } catch (error) {
        console.error('CSVå¯¼å‡ºå¤±è´¥:', error);
        alert('CSVå¯¼å‡ºå¤±è´¥: ' + error.message);
      }
    }

    // Load records from localStorage on startup
    function initialLoad() {
        // é¦–å…ˆåŠ è½½åœ°ç†ç¼–ç ç¼“å­˜
        loadGeocodeCache();
        
        const savedTheme = localStorage.getItem('theme') || 'light';
        map = new AMap.Map('container', {
          center: [106.712, 34.205],
          zoom: 5,
          mapStyle: savedTheme === 'dark' ? DARK_MAP_STYLE : LIGHT_MAP_STYLE,
        });

        // ä»localStorageåŠ è½½è®°å½•
        records = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
        
        // å…ˆæ¸…ç©ºè¡¨æ ¼
        tbody.innerHTML = '';
        
        // æ·»åŠ è®°å½•åˆ°è¡¨æ ¼ï¼ˆä¸ç»˜åˆ¶åœ°å›¾ï¼‰
        records.forEach(rec => {
          const tr = document.createElement('tr');
          const rpk = rec.distance > 0 ? (rec.cost / rec.distance).toFixed(4) : '';
          tr.innerHTML = `
            <td></td> <!-- Seq # updated later -->
            <td>${rec.date || ''}</td>
            <td>${rec.time || ''}</td>
            <td>${rec.duration || ''}</td>
            <td>${rec.trainNo || ''}</td>
            <td>${rec.startStation || ''}</td>
            <td>${rec.startCity || ''}</td>
            <td>${rec.endStation || ''}</td>
            <td>${rec.endCity || ''}</td>
            <td>${rec.seatClass || ''}</td>
            <td>${rec.trainType || ''}</td>
            <td>${rec.bureau || ''}</td>
            <td>${(rec.cost || 0).toFixed(2)}</td>
            <td>${rec.distance || 0}</td>
            <td>${rpk}</td>
            <td>${rec.notes || ''}</td>
            <td>
              <button class="gemini" title="è·å–ç›®çš„åœ°æ—…æ¸¸æ”»ç•¥">âœ¨</button>
              <button class="modify">ä¿®æ”¹</button>
              <button class="insert">æ’å…¥</button>
              <button class="delete">åˆ é™¤</button>
            </td>
          `;
          tbody.appendChild(tr);
          attachRowEvents(tr);
        });
        
        updateSequenceNumbers();
        
        // åˆå§‹åŒ–æ€»ç»“é¢æ¿å’Œå›¾è¡¨
        updateSummaryPanels();

        // åœ°å›¾å®Œå…¨åŠ è½½åç»˜åˆ¶æ‰€æœ‰è·¯å¾„
        map.on('complete', async function() {
          // æ¸…ç©ºè®¡æ•°å™¨
          Object.keys(counts).forEach(key => delete counts[key]);
          
          // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç«™ç‚¹éƒ½å·²ç¼“å­˜
          const missingStations = new Set();
          records.forEach(rec => {
            const startKey = (rec.startCity || '') + (rec.startStation || '') + 'ç«™';
            const endKey = (rec.endCity || '') + (rec.endStation || '') + 'ç«™';
            if (rec.startStation && !geocodeCache[startKey]) {
              missingStations.add(startKey);
            }
            if (rec.endStation && !geocodeCache[endKey]) {
              missingStations.add(endKey);
            }
          });
          
          console.log(`ç¼“å­˜çŠ¶æ€: æ€»ç«™ç‚¹ ${Object.keys(geocodeCache).length} ä¸ªï¼Œéœ€è¦æŸ¥è¯¢ ${missingStations.size} ä¸ªæ–°ç«™ç‚¹`);
          
          // è·å–æ‰€æœ‰è¡¨æ ¼è¡Œå¹¶ç»˜åˆ¶å¯¹åº”çš„è·¯å¾„
          const allRows = Array.from(tbody.children);
          let successCount = 0;
          let failCount = 0;
          
          for (let i = 0; i < allRows.length; i++) {
            const tr = allRows[i];
            const rec = records[i];
            if (rec && rec.startStation && rec.endStation) {
              try {
                await drawPath(tr, rec);
                successCount++;
                console.log(`æˆåŠŸç»˜åˆ¶è·¯å¾„ ${i + 1}/${allRows.length}: ${rec.startStation} â†’ ${rec.endStation}`);
                
                // åªæœ‰åœ¨éœ€è¦APIè°ƒç”¨æ—¶æ‰å»¶è¿Ÿ
                const startKey = (rec.startCity || '') + (rec.startStation || '') + 'ç«™';
                const endKey = (rec.endCity || '') + (rec.endStation || '') + 'ç«™';
                const needsApi = !geocodeCache[startKey] || !geocodeCache[endKey];
                if (needsApi) {
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              } catch (error) {
                failCount++;
                console.error(`ç»˜åˆ¶è·¯å¾„å¤±è´¥ ${i + 1}/${allRows.length}:`, rec.startStation, 'â†’', rec.endStation, error.message);
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }
          }
          
          console.log(`è·¯å¾„ç»˜åˆ¶å®Œæˆ: æˆåŠŸ ${successCount}, å¤±è´¥ ${failCount}`);
          if (failCount > 0) {
            console.warn('éƒ¨åˆ†è·¯å¾„ç»˜åˆ¶å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç”±äºAPIé…é¢é™åˆ¶ã€‚å¤§éƒ¨åˆ†ç«™ç‚¹åæ ‡å·²ç¼“å­˜ï¼Œåç»­åˆ·æ–°ä¼šæ›´å¿«ã€‚');
          }
          
          // ç»˜åˆ¶å®Œæˆåæ›´æ–°å›¾ä¾‹
          updateYearLegend();
        });

        clearForm();
    }

    window.onload = initialLoad;

  </script>
</body>
</html>
