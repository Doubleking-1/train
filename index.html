<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>火车票记录与地图示例（含暗色模式）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- 引入高德地图 JS API 核心库 -->
  <script src="https://webapi.amap.com/maps?v=1.4.15&key=7e67c88a1371c1d3ac14e3afcfb81a74"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- 引入SheetJS库用于解析Excel文件 -->
  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <!-- 引入Chart.js库用于绘制图表 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* 主题变量 */
    :root {
      --bg-color: #f8f9fa;
      --sidebar-bg: #ffffff;
      --text-color: #212529;
      --border-color: #dee2e6;
      --form-bg: #ffffff;
      --table-head-bg: #f2f2f2;
      --table-border: #dee2e6;
      --primary-color: #007bff;
      --input-bg: #fff;
      --input-border: #ced4da;
      --modal-bg: #ffffff;
      --btn-bg: #f0f0f0;
      --btn-text: #333;
      --btn-border: #ccc;
    }

    .dark {
      --bg-color: #121212;
      --sidebar-bg: #1e1e1e;
      --text-color: #e0e0e0;
      --border-color: #444;
      --form-bg: #2a2a2a;
      --table-head-bg: #2c2c2c;
      --table-border: #444;
      --primary-color: #66aaff;
      --input-bg: #333;
      --input-border: #555;
      --modal-bg: #2d2d2d;
      --btn-bg: #3a3a3a;
      --btn-text: #e0e0e0;
      --btn-border: #555;
    }

    /* 全局布局 */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      font-size: 14px; /* Smaller base font size */
    }

    #sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 250px; /* 缩窄侧边栏，从300px改为250px */
      background: var(--sidebar-bg);
      border-right: 1px solid var(--border-color);
      padding: 10px;
      overflow-y: auto;
      box-sizing: border-box;
      transition: background-color 0.3s, border-color 0.3s;
      z-index: 10;
    }

    #main {
      margin-left: 250px; /* 调整主区域左边距，从300px改为250px */
      padding: 15px;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    /* 切换按钮 */
    #themeToggle {
      width: 100%;
      margin-bottom: 10px;
      padding: 8px;
      background: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #themeToggle:hover {
      opacity: 0.9;
    }

    /* 表单 */
    h2 {
      margin-top: 0;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 8px;
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    #modeIndicator {
      font-size: 12px;
      color: var(--primary-color);
      margin-bottom: 8px;
      font-weight: bold;
    }
    #form {
      background: var(--form-bg);
      padding: 10px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }
    .form-group {
      margin-bottom: 8px;
    }
    .form-group label {
      display: block;
      font-size: 12px;
      color: var(--text-color);
      margin-bottom: 4px;
    }

    .form-group input {
      width: 100%;
      padding: 6px 8px; /* Smaller padding */
      box-sizing: border-box;
      border: 1px solid var(--input-border);
      border-radius: 3px;
      font-size: 12px; /* Smaller font */
      background: var(--input-bg);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }
    #addRecordBtn {
      width: 100%;
      padding: 8px;
      background: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 8px;
    }

    /* 历史表格 */
    #historyTable {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
      margin-bottom: 15px;
    }
    #historyTable th, #historyTable td {
      border: 1px solid var(--table-border);
      padding: 6px 8px; /* Smaller padding */
      font-size: 12px; /* Smaller font */
      white-space: nowrap;
      text-align: left;
    }
    #historyTable th {
      background: var(--table-head-bg);
      font-weight: 600;
    }
    #historyTable button {
      margin-right: 4px;
      padding: 2px 6px;
      font-size: 11px;
      cursor: pointer;
      background-color: var(--btn-bg);
      color: var(--btn-text);
      border: 1px solid var(--btn-border);
      border-radius: 3px;
      transition: background-color 0.2s;
    }
    #historyTable button:hover {
        opacity: 0.8;
    }
    #historyTable button.gemini {
        background: transparent;
        border: none;
        padding: 2px;
    }
    .dark #addRecordBtn {
        color: #111; /* Dark text on primary color button */
    }


    /* 地图容器 */
    #container {
      width: 100%;
      height: 80vh; /* Taller map */
      margin: 0;
      border-radius: 5px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      position: relative; /* 为图例定位做准备 */
    }

    /* 地图右上角标记切换按钮样式 */
    #markerToggle {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1001;
      padding: 8px 12px;
      background: rgba(40, 167, 69, 0.9);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    #markerToggle:hover {
      background: rgba(40, 167, 69, 1);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    #markerToggle.hide-markers {
      background: rgba(220, 53, 69, 0.9);
    }

    #markerToggle.hide-markers:hover {
      background: rgba(220, 53, 69, 1);
    }

    .dark #markerToggle {
      background: rgba(40, 167, 69, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .dark #markerToggle.hide-markers {
      background: rgba(220, 53, 69, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* 年份图例样式 - 调整位置避免与按钮重叠 */
    #yearLegend {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: var(--modal-bg);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 8px;
      max-height: 300px;
      overflow-y: auto;
      min-width: 120px;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    #yearLegend h4 {
      margin: 0 0 6px 0;
      font-size: 12px;
      color: var(--text-color);
      text-align: center;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 4px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      font-size: 11px;
      color: var(--text-color);
    }

    .legend-color {
      width: 16px;
      height: 3px;
      margin-right: 6px;
      border-radius: 1px;
    }

    .legend-text {
      flex: 1;
    }

    /* Gemini Modal */
    #geminiModalOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
    }
    #geminiModal {
      background-color: var(--modal-bg);
      color: var(--text-color);
      padding: 20px;
      border-radius: 8px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }
    #geminiModal h3 {
        margin-top: 0;
        color: var(--primary-color);
    }
    #geminiModalClose {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        border: none;
        background: none;
        color: var(--text-color);
    }
    #geminiResult {
        white-space: pre-wrap; /* To respect newlines from API */
        line-height: 1.6;
    }
    .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: var(--primary-color);
        animation: spin 1s ease infinite;
        margin: 20px auto;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* 总结面板样式 */
    #summaryPanel {
      margin-bottom: 15px;
      background: var(--form-bg);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      overflow: hidden;
    }

    .summary-tabs {
      display: flex;
      background: var(--table-head-bg);
      border-bottom: 1px solid var(--border-color);
    }

    .summary-tab {
      flex: 1;
      padding: 10px 15px;
      background: transparent;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
    }

    .summary-tab:hover {
      background: var(--primary-color);
      color: white;
    }

    .summary-tab.active {
      background: var(--primary-color);
      color: white;
      border-bottom-color: #0056b3;
    }

    .summary-content {
      padding: 15px;
      display: none;
    }

    .summary-content.active {
      display: block;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 15px;
    }

    .stat-card {
      background: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 12px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-color);
      opacity: 0.8;
    }

    .year-selector {
      margin-bottom: 15px;
      text-align: center;
    }

    .year-selector select {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--input-bg);
      color: var(--text-color);
      font-size: 14px;
      cursor: pointer;
    }

    /* 图表容器样式 */
    #chartsPanel {
      margin-top: 20px;
      background: var(--form-bg);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 20px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .chart-container {
      background: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 15px;
      height: 300px;
      position: relative;
    }

    .chart-title {
      text-align: center;
      font-size: 14px;
      font-weight: bold;
      color: var(--text-color);
      margin-bottom: 10px;
    }

    @media (max-width: 768px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>

  <!-- Sidebar: Form + Theme Toggle -->
  <div id="sidebar">
    <button id="themeToggle">切换暗色模式</button>
    
    <h2>火车票记录</h2
    
    <!-- 数据导入导出按钮 -->
    <div style="margin-bottom: 15px; display: flex; gap: 5px;">
      <button id="importCsvBtn" style="flex: 1; padding: 8px; font-size: 12px; background: #fd7e14; color: white; border: none; border-radius: 3px; cursor: pointer;">📄 导入CSV</button>
      <button id="exportCsvBtn" style="flex: 1; padding: 8px; font-size: 12px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">💾 导出CSV</button>
    </div>
    
    <input type="file" id="importCsvFile" accept=".csv" style="display: none;">
    
    <div id="modeIndicator">当前操作：添加</div>
    <div id="form">
      <div class="form-group"><label>序号</label><input id="seq" type="number" readonly></div>
      <div class="form-group"><label>日期</label><input id="date" type="date"></div>
      <div class="form-group"><label>时间</label><input id="time" type="time"></div>
      <div class="form-group"><label>时长 (hh:mm)</label><input id="duration" placeholder="例如 07:54"></div>
      <div class="form-group"><label>车次</label><input id="trainNo"></div>
      <div class="form-group"><label>起点站</label><input id="startStation"></div>
      <div class="form-group"><label>起点城市</label><input id="startCity"></div>
      <div class="form-group"><label>终点站</label><input id="endStation"></div>
      <div class="form-group"><label>终点城市</label><input id="endCity"></div>
      <div class="form-group"><label>座席</label><input id="seatClass"></div>
      <div class="form-group"><label>车型号</label><input id="trainType"></div>
      <div class="form-group"><label>铁路局</label><input id="bureau"></div>
      <div class="form-group"><label>费用 (RMB)</label><input id="cost" type="number" step="0.01"></div>
      <div class="form-group"><label>里程 (km)</label><input id="distance" type="number"></div>
      <div class="form-group"><label>RMB/km</label><input id="pricePerKm" readonly></div>
      <div class="form-group"><label>备注</label><input id="notes"></div>
      <button id="addRecordBtn">添加记录</button>
    </div>
  </div>

  <!-- Main Area: Summary + Map + Table -->
  <div id="main">
    <!-- 总结面板 -->
    <div id="summaryPanel">
      <div class="summary-tabs">
        <button class="summary-tab active" data-tab="all">历史总结</button>
        <button class="summary-tab" data-tab="yearly">年度总结</button>
      </div>

      <!-- 历史总结内容 -->
      <div id="allSummary" class="summary-content active">
        <div class="stats-grid" id="allStatsGrid">
          <!-- 统计卡片将通过JavaScript动态生成 -->
        </div>
      </div>

      <!-- 年度总结内容 -->
      <div id="yearlySummary" class="summary-content">
        <div class="year-selector">
          <select id="yearSelect">
            <option value="">请选择年份</option>
          </select>
        </div>
        <div class="stats-grid" id="yearlyStatsGrid">
          <!-- 统计卡片将通过JavaScript动态生成 -->
        </div>
      </div>
    </div>

    <!-- 图表面板 -->
    <div id="chartsPanel">
      <div class="charts-grid">
        <div class="chart-container">
          <div class="chart-title">年度乘车次数</div>
          <canvas id="tripsChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">年度里程 (公里)</div>
          <canvas id="distanceChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">年度花费 (元)</div>
          <canvas id="costChart"></canvas>
        </div>
        <div class="chart-container">
          <div class="chart-title">年度乘车时长 (小时)</div>
          <canvas id="durationChart"></canvas>
        </div>
      </div>
    </div>

    <div id="container">
      <!-- 标记切换按钮移到地图右上角 -->
      <button id="markerToggle">显示地点标记</button>
      
      <!-- 年份图例 -->
      <div id="yearLegend">
        <h4>年份图例</h4>
        <div id="legendContent"></div>
      </div>
    </div>
    
    <table id="historyTable">
      <thead>
        <tr>
          <th>#</th><th>日期</th><th>时间</th><th>时长</th><th>车次</th><th>起点站</th><th>起点城市</th><th>终点站</th><th>终点城市</th><th>座席</th><th>车型号</th><th>铁路局</th><th>费用</th><th>里程</th><th>RMB/km</th><th>备注</th><th>操作</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Gemini Modal -->
  <div id="geminiModalOverlay">
      <div id="geminiModal">
          <button id="geminiModalClose">&times;</button>
          <h3 id="geminiModalTitle"></h3>
          <div id="geminiResult">
              <div class="spinner"></div>
          </div>
      </div>
  </div>

  <script>
    // --- Global Variables & Constants ---
    const REST_KEY = '0a6359d1470048a89ba86cfb5f53f2e9'; // Please use your own key
    const STORAGE_KEY = 'trainRecords';
    const GEOCODE_CACHE_KEY = 'geocodeCache'; // 新增：地理编码缓存键
    const LIGHT_MAP_STYLE = 'amap://styles/normal';
    const DARK_MAP_STYLE = 'amap://styles/dark';
    let records = [];
    let insertionTarget = null;
    let currentMode = 'add'; // 'add' | 'modify' | 'insert'
    const counts = {}; // For offsetting duplicate paths
    let map; // Declare map variable here
    
    // 新增：地理编码缓存
    let geocodeCache = {};

    // 新增：标记显示状态
    let showMarkers = false;

    // --- UI Elements ---
    const themeToggle = document.getElementById('themeToggle');
    const modeIndicator = document.getElementById('modeIndicator');
    const addBtn = document.getElementById('addRecordBtn');
    const tbody = document.querySelector('#historyTable tbody');
    // Form inputs
    const seqInput = document.getElementById('seq');
    const costInput = document.getElementById('cost');
    const distanceInput = document.getElementById('distance');
    const pricePerKmInput = document.getElementById('pricePerKm');
    const endStationInput = document.getElementById('endStation');

    // Gemini Feature Elements
    const geminiModalOverlay = document.getElementById('geminiModalOverlay');
    const geminiModalClose = document.getElementById('geminiModalClose');
    const geminiModalTitle = document.getElementById('geminiModalTitle');
    const geminiResult = document.getElementById('geminiResult');
    const markerToggle = document.getElementById('markerToggle');
    const yearLegend = document.getElementById('yearLegend');
    const legendContent = document.getElementById('legendContent');
    const startCityInput = document.getElementById('startCity');
    const endCityInput = document.getElementById('endCity');
    const yearSelect = document.getElementById('yearSelect');

    // 图表实例
    let tripsChart, distanceChart, costChart, durationChart;

    // --- Functions ---

    // Update map theme based on body class
    function updateMapTheme() {
      const isDark = document.body.classList.contains('dark');
      if (map) { // Ensure map is initialized
        map.setMapStyle(isDark ? DARK_MAP_STYLE : LIGHT_MAP_STYLE);
      }
      // 更新图表主题
      updateChartsTheme();
    }

    // Calculate RMB/km
    function updatePricePerKm() {
      const c = parseFloat(costInput.value) || 0;
      const d = parseFloat(distanceInput.value) || 0;
      pricePerKmInput.value = d > 0 ? (c / d).toFixed(4) : '';
    }

    // Save records to localStorage
    function saveRecords() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(records));
    }

    // 计算总时长（将时长字符串转换为分钟数）
    function parseDurationToMinutes(duration) {
      if (!duration) return 0;
      const match = duration.match(/(\d{1,2}):(\d{1,2})/);
      if (match) {
        const hours = parseInt(match[1]) || 0;
        const minutes = parseInt(match[2]) || 0;
        return hours * 60 + minutes;
      }
      return 0;
    }

    // 将分钟数转换为时长字符串
    function formatMinutesToDuration(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours}小时${mins}分钟`;
    }

    // 更新历史总结
    function updateAllTimeSummary() {
      const container = document.getElementById('allStatsGrid');
      
      if (records.length === 0) {
        container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999;">暂无数据</div>';
        return;
      }

      // 统计数据
      const totalTrips = records.length;
      const totalCost = records.reduce((sum, r) => sum + (r.cost || 0), 0);
      const totalDistance = records.reduce((sum, r) => sum + (r.distance || 0), 0);
      const totalMinutes = records.reduce((sum, r) => sum + parseDurationToMinutes(r.duration), 0);
      
      // 统计城市（只看起点城市和终点城市）
      const cities = new Set();
      records.forEach(r => {
        if (r.startCity && r.startCity.trim()) {
          cities.add(r.startCity.trim());
        }
        if (r.endCity && r.endCity.trim()) {
          cities.add(r.endCity.trim());
        }
      });

      // 统计年份
      const years = new Set();
      records.forEach(r => {
        if (r.date) {
          years.add(r.date.substring(0, 4));
        }
      });

      // 找出最远和最近的行程
      const longestTrip = records.reduce((a, r) => (r.distance || 0) > (a.distance || 0) ? r : a, records[0]);
      const shortestTrip = records.reduce((a, r) => (r.distance || 0) < (a.distance || 0) ? r : a, records[0]);

      // 找出最贵和最便宜的行程
      const mostExpensive = records.reduce((a, r) => (r.cost || 0) > (a.cost || 0) ? r : a, records[0]);
      const cheapest = records.reduce((a, r) => (r.cost || 0) < (a.cost || 0) ? r : a, records[0]);

      // 平均值
      const avgCost = totalTrips > 0 ? (totalCost / totalTrips).toFixed(2) : 0;
      const avgDistance = totalTrips > 0 ? (totalDistance / totalTrips).toFixed(1) : 0;
      const avgDuration = totalTrips > 0 ? formatMinutesToDuration(Math.round(totalMinutes / totalTrips)) : '0分钟';

      // 生成统计卡片
      container.innerHTML = `
        <div class="stat-card">
          <div class="stat-value">${totalTrips}</div>
          <div class="stat-label">总行程数</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">¥${totalCost.toFixed(2)}</div>
          <div class="stat-label">总花费</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${totalDistance.toLocaleString()}</div>
          <div class="stat-label">总里程 (公里)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatMinutesToDuration(totalMinutes)}</div>
          <div class="stat-label">总乘车时长</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${cities.size}</div>
          <div class="stat-label">到访城市数</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${years.size}</div>
          <div class="stat-label">跨越年份</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">¥${avgCost}</div>
          <div class="stat-label">平均票价</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDistance}公里</div>
          <div class="stat-label">平均里程</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDuration}</div>
          <div class="stat-label">平均时长</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${longestTrip.startCity || longestTrip.startStation} → ${longestTrip.endCity || longestTrip.endStation}</div>
          <div class="stat-label">最远行程 (${longestTrip.distance}公里)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostExpensive.startCity || mostExpensive.startStation} → ${mostExpensive.endCity || mostExpensive.endStation}</div>
          <div class="stat-label">最贵行程 (¥${mostExpensive.cost})</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${(totalDistance / 40075).toFixed(2)}</div>
          <div class="stat-label">绕地球圈数</div>
        </div>
      `;
    }

    // 更新年份选择器
    function updateYearSelect() {
      const years = [...new Set(records.map(r => {
        if (r.date) {
          return r.date.substring(0, 4);
        }
        return null;
      }).filter(y => y))].sort((a, b) => parseInt(b) - parseInt(a));

      yearSelect.innerHTML = '<option value="">请选择年份</option>';
      years.forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = `${year}年`;
        yearSelect.appendChild(option);
      });
    }

    // 更新年度总结
    function updateYearlySummary(year) {
      const container = document.getElementById('yearlyStatsGrid');
      
      if (!year) {
        container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999;">请选择年份</div>';
        return;
      }

      const yearRecords = records.filter(r => r.date && r.date.substring(0, 4) === year);
      
      if (yearRecords.length === 0) {
        container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999;">该年份暂无数据</div>';
        return;
      }

      // 统计数据
      const totalTrips = yearRecords.length;
      const totalCost = yearRecords.reduce((sum, r) => sum + (r.cost || 0), 0);
      const totalDistance = yearRecords.reduce((sum, r) => sum + (r.distance || 0), 0);
      const totalMinutes = yearRecords.reduce((sum, r) => sum + parseDurationToMinutes(r.duration), 0);
      
      // 统计城市（只看起点城市和终点城市）
      const cities = new Set();
      yearRecords.forEach(r => {
        if (r.startCity && r.startCity.trim()) {
          cities.add(r.startCity.trim());
        }
        if (r.endCity && r.endCity.trim()) {
          cities.add(r.endCity.trim());
        }
      });

      // 统计铁路局（去重）
      const bureaus = new Set();
      yearRecords.forEach(r => {
        if (r.bureau && r.bureau.trim()) {
          bureaus.add(r.bureau.trim());
        }
      });

      // 统计月份分布
      const monthStats = Array.from({ length: 12 }, () => ({ trips: 0, cost: 0, distance: 0 }));
      yearRecords.forEach(r => {
        const month = new Date(r.date).getMonth();
        monthStats[month].trips++;
        monthStats[month].cost += r.cost || 0;
        monthStats[month].distance += r.distance || 0;
      });

      const mostActiveMonth = monthStats.reduce((max, current, index) => 
        current.trips > max.trips ? { ...current, month: index + 1 } : max, 
        { trips: 0, month: 1 }
      );

      // 找出最常去的路线
      const routeCounts = {};
      yearRecords.forEach(r => {
        const route = `${r.startCity || r.startStation} → ${r.endCity || r.endStation}`;
        routeCounts[route] = (routeCounts[route] || 0) + 1;
      });
      const mostFrequentRoute = Object.entries(routeCounts).reduce((a, v) => 
        v[1] > a[1] ? v : a, ['', 0]
      );

      // 找出最常乘坐的铁路局
      const bureauCounts = {};
      yearRecords.forEach(r => {
        if (r.bureau && r.bureau.trim()) {
          bureauCounts[r.bureau.trim()] = (bureauCounts[r.bureau.trim()] || 0) + 1;
        }
      });
      const mostFrequentBureau = Object.entries(bureauCounts).reduce((a, v) => 
        v[1] > a[1] ? v : a, ['', 0]
      );

      // 平均值
      const avgCost = (totalCost / totalTrips).toFixed(2);
      const avgDistance = (totalDistance / totalTrips).toFixed(1);
      const avgDuration = formatMinutesToDuration(Math.round(totalMinutes / totalTrips));

      // 计算占总体比例
      const allTotalCost = records.reduce((sum, r) => sum + (r.cost || 0), 0);
      const allTotalDistance = records.reduce((sum, r) => sum + (r.distance || 0), 0);

      // 生成统计卡片
      container.innerHTML = `
        <div class="stat-card">
          <div class="stat-value">${totalTrips}</div>
          <div class="stat-label">${year}年总行程</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">¥${totalCost.toFixed(2)}</div>
          <div class="stat-label">${year}年总花费</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${totalDistance.toLocaleString()}</div>
          <div class="stat-label">${year}年总里程 (公里)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${formatMinutesToDuration(totalMinutes)}</div>
          <div class="stat-label">${year}年总时长</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${cities.size}</div>
          <div class="stat-label">到访城市数</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${bureaus.size}</div>
          <div class="stat-label">涉及铁路局</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostActiveMonth.month}月</div>
          <div class="stat-label">最活跃月份 (${mostActiveMonth.trips}次)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">¥${avgCost}</div>
          <div class="stat-label">平均票价</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDistance}公里</div>
          <div class="stat-label">平均里程</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${avgDuration}</div>
          <div class="stat-label">平均时长</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostFrequentRoute[0]}</div>
          <div class="stat-label">最常路线 (${mostFrequentRoute[1]}次)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${mostFrequentBureau[0] || '无数据'}</div>
          <div class="stat-label">最常铁路局 (${mostFrequentBureau[1] || 0}次)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${allTotalCost > 0 ? (totalCost / allTotalCost * 100).toFixed(1) : 0}%</div>
          <div class="stat-label">占总花费比例</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${allTotalDistance > 0 ? (totalDistance / allTotalDistance * 100).toFixed(1) : 0}%</div>
          <div class="stat-label">占总里程比例</div>
        </div>
      `;
    }

    // 根据年份生成颜色的函数（提取为独立函数以便复用）
    function getYearColor(year) {
        const colors = [
            '#FF0000', // 红色
            '#00FF00', // 绿色  
            '#0000FF', // 蓝色
            '#FFD700', // 金色
            '#FF69B4', // 粉色
            '#00FFFF', // 青色
            '#FF4500', // 橙红色
            '#9370DB', // 紫色
            '#32CD32', // 酸橙绿
            '#FF1493', // 深粉色
            '#00CED1', // 暗绿松石色
            '#FF6347', // 番茄色
            '#4169E1', // 皇家蓝
            '#DC143C', // 深红色
            '#228B22', // 森林绿
            '#B22222', // 火砖色
            '#4B0082', // 靛蓝
            '#DAA520', // 金杆色
            '#8A2BE2', // 蓝紫色
            '#FF8C00'  // 暗橙色
        ];
        
        const yearNum = parseInt(year) || new Date().getFullYear();
        const colorIndex = yearNum % colors.length;
        return colors[colorIndex];
    }

    // 更新年份图例 - 从日期提取年份
    function updateYearLegend() {
        // 统计每年的记录数量
        const yearStats = {};
        records.forEach(record => {
            const year = record.date ? record.date.substring(0, 4) : new Date().getFullYear().toString();
            yearStats[year] = (yearStats[year] || 0) + 1;
        });

        // 清空图例内容
        legendContent.innerHTML = '';

        // 按年份排序
        const sortedYears = Object.keys(yearStats).sort((a, b) => parseInt(a) - parseInt(b));

        if (sortedYears.length === 0) {
            legendContent.innerHTML = '<div style="font-size: 10px; color: #999; text-align: center;">暂无数据</div>';
            return;
        }

        // 生成图例项
        sortedYears.forEach(year => {
            const count = yearStats[year];
            const color = getYearColor(year);
            
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            legendItem.innerHTML = `
                <div class="legend-color" style="background-color: ${color};"></div>
                <div class="legend-text">${year}年 (${count}次)</div>
            `;
            legendContent.appendChild(legendItem);
        });
    }

    // 创建年度统计图表
    function createYearlyCharts() {
      if (records.length === 0) return;

      // 按年份统计数据
      const yearlyData = {};
      records.forEach(record => {
        const year = record.date ? record.date.substring(0, 4) : new Date().getFullYear().toString();
        if (!yearlyData[year]) {
          yearlyData[year] = {
            trips: 0,
            distance: 0,
            cost: 0,
            duration: 0 // 以分钟为单位
          };
        }
        yearlyData[year].trips++;
        yearlyData[year].distance += record.distance || 0;
        yearlyData[year].cost += record.cost || 0;
        yearlyData[year].duration += parseDurationToMinutes(record.duration);
      });

      // 排序年份
      const years = Object.keys(yearlyData).sort((a, b) => parseInt(a) - parseInt(b));
      const trips = years.map(year => yearlyData[year].trips);
      const distances = years.map(year => yearlyData[year].distance);
      const costs = years.map(year => yearlyData[year].cost);
      const durations = years.map(year => Math.round(yearlyData[year].duration / 60)); // 转换为小时

      // 获取当前主题的文字颜色
      const isDark = document.body.classList.contains('dark');
      const textColor = isDark ? '#e0e0e0' : '#212529';

      // 通用图表配置
      const commonOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          }
        },
        scales: {
          x: {
            grid: {
              display: false // 移除网格线
            },
            ticks: {
              color: textColor,
              padding: 10 // 增加标签与坐标轴的距离
            }
          },
          y: {
            beginAtZero: true,
            grid: {
              display: false // 移除网格线
            },
            ticks: {
              color: textColor
            }
          }
        }
      };

      // 销毁已存在的图表
      if (tripsChart) tripsChart.destroy();
      if (distanceChart) distanceChart.destroy();
      if (costChart) costChart.destroy();
      if (durationChart) durationChart.destroy();

      // 乘车次数图表
      const tripsCtx = document.getElementById('tripsChart').getContext('2d');
      tripsChart = new Chart(tripsCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: trips,
            backgroundColor: 'rgba(54, 162, 235, 0.6)',
            borderColor: 'rgba(54, 162, 235, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });

      // 里程图表
      const distanceCtx = document.getElementById('distanceChart').getContext('2d');
      distanceChart = new Chart(distanceCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: distances,
            backgroundColor: 'rgba(255, 99, 132, 0.6)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });

      // 花费图表
      const costCtx = document.getElementById('costChart').getContext('2d');
      costChart = new Chart(costCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: costs,
            backgroundColor: 'rgba(255, 206, 86, 0.6)',
            borderColor: 'rgba(255, 206, 86, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });

      // 时长图表
      const durationCtx = document.getElementById('durationChart').getContext('2d');
      durationChart = new Chart(durationCtx, {
        type: 'bar',
        data: {
          labels: years,
          datasets: [{
            data: durations,
            backgroundColor: 'rgba(75, 192, 192, 0.6)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
          }]
        },
        options: commonOptions
      });
    }

    // 更新主题颜色时重新创建图表
    function updateChartsTheme() {
      if (tripsChart || distanceChart || costChart || durationChart) {
        // 延迟执行以确保CSS变量已更新
        setTimeout(() => {
          createYearlyCharts();
        }, 100);
      }
    }

    // 更新所有总结面板
    function updateSummaryPanels() {
      updateAllTimeSummary();
      updateYearSelect();
      const selectedYear = yearSelect.value;
      if (selectedYear) {
        updateYearlySummary(selectedYear);
      }
      
      // 更新图表
      createYearlyCharts();
    }

    // Save geocode results to localStorage
    function saveGeocodeCache() {
      try {
        localStorage.setItem(GEOCODE_CACHE_KEY, JSON.stringify(geocodeCache));
      } catch (error) {
        console.error('保存地理编码缓存失败:', error);
      }
    }

    // Load geocode results from localStorage
    function loadGeocodeCache() {
      try {
        const cached = localStorage.getItem(GEOCODE_CACHE_KEY);
        if (cached) {
          geocodeCache = JSON.parse(cached);
          console.log(`已加载 ${Object.keys(geocodeCache).length} 个缓存的地理编码结果`);
        }
      } catch (error) {
        console.error('加载地理编码缓存失败:', error);
        geocodeCache = {};
      }
    }

    // Update sequence numbers in the table
    function updateSequenceNumbers() {
      Array.from(tbody.children).forEach((tr, i) => {
        tr.cells[0].innerText = i + 1;
      });
    }

    // Set the current operation mode ('add', 'modify', 'insert')
    function setMode(mode, targetTr = null) {
      currentMode = mode;
      insertionTarget = targetTr; // Used for 'insert' and 'modify' modes
      
      if (mode === 'modify') {
        modeIndicator.textContent = '当前操作：修改';
        addBtn.textContent = '保存修改';
      } else if (mode === 'insert') {
        modeIndicator.textContent = '当前操作：插入';
        addBtn.textContent = '在此行后插入';
      } else { // 'add' mode
        modeIndicator.textContent = '当前操作：添加';
        addBtn.textContent = '添加记录';
        insertionTarget = null;
      }
      updateSeqInput();
    }

    // Update the sequence input field based on the mode
    function updateSeqInput() {
      if (currentMode === 'insert' && insertionTarget) {
        const idx = Array.from(tbody.children).indexOf(insertionTarget);
        seqInput.value = idx + 2;
      } else if (currentMode === 'modify') {
        // seqInput is already populated
      } else { // 'add' mode
        seqInput.value = tbody.children.length + 1;
      }
    }

    // Clear the input form
    function clearForm() {
      ['date','time','duration','trainNo','startStation','startCity','endStation','endCity','seatClass','trainType','bureau','cost','distance','notes']
        .forEach(id => document.getElementById(id).value = '');
      updatePricePerKm();
      updateSeqInput();
    }

    // Attach event listeners to buttons in a table row
    function attachRowEvents(tr) {
      // Delete button
      tr.querySelector('.delete').addEventListener('click', (e) => {
        e.stopPropagation();
        tr._overlays?.forEach(o => o.setMap(null));
        tr.remove();
        updateSequenceNumbers();
        if (currentMode !== 'add') {
          clearForm();
          setMode('add');
        }
        syncRecordsFromTable();
      });

      // Modify button
      tr.querySelector('.modify').addEventListener('click', (e) => {
        e.stopPropagation();
        const c = tr.cells;
        seqInput.value = c[0].innerText;
        document.getElementById('date').value = c[1].innerText;
        document.getElementById('time').value = c[2].innerText;
        document.getElementById('duration').value = c[3].innerText;
        document.getElementById('trainNo').value = c[4].innerText;
        document.getElementById('startStation').value = c[5].innerText;
        startCityInput.value = c[6].innerText;
        document.getElementById('endStation').value = c[7].innerText;
        endCityInput.value = c[8].innerText;
        document.getElementById('seatClass').value = c[9].innerText;
        document.getElementById('trainType').value = c[10].innerText;
        document.getElementById('bureau').value = c[11].innerText;
        costInput.value = c[12].innerText;
        distanceInput.value = c[13].innerText;
        pricePerKmInput.value = c[14].innerText;
        document.getElementById('notes').value = c[15].innerText;
        setMode('modify', tr);
      });
      
      // Insert button
      tr.querySelector('.insert').addEventListener('click', (e) => {
        e.stopPropagation();
        clearForm();
        setMode('insert', tr);
      });

      // Gemini button in table row
      tr.querySelector('.gemini').addEventListener('click', (e) => {
        e.stopPropagation();
        const city = tr.cells[8].innerText; // 使用终点城市
        if (city) {
            getTravelGuide(city);
        } else {
            alert("该记录没有终点城市信息。");
        }
      });
    }

    // 优化地理编码函数，使用城市+站点的组合
    function geocode(station, city) {
      if (!station) return Promise.reject(new Error('Station is empty'));
      
      // 构建搜索地址：城市+站点+"站"
      let searchAddr = '';
      if (city && city.trim()) {
        searchAddr = city.trim() + station.trim();
        if (!searchAddr.endsWith('站')) {
          searchAddr += '站';
        }
      } else {
        searchAddr = station.endsWith('站') ? station : station + '站';
      }
      
      // 使用组合地址作为缓存键
      const cacheKey = searchAddr;
      
      // 检查缓存
      if (geocodeCache[cacheKey]) {
        console.log(`使用缓存的地理编码结果: ${cacheKey}`);
        return Promise.resolve(geocodeCache[cacheKey]);
      }
      
      const url = new URL('https://restapi.amap.com/v3/geocode/geo');
      url.search = new URLSearchParams({ key: REST_KEY, address: searchAddr, city: '全国' }).toString();
      
      console.log(`地理编码搜索: "${station}" + "${city}" -> "${searchAddr}"`);
      
      return fetch(url)
        .then(r => r.json())
        .then(data => {
          if (data.status === '1' && data.geocodes.length) {
            const coords = data.geocodes[0].location.split(',').map(Number);
            // 保存到缓存
            geocodeCache[cacheKey] = coords;
            saveGeocodeCache();
            console.log(`地理编码成功: ${searchAddr} -> [${coords[0]}, ${coords[1]}]`);
            return coords;
          }
          throw new Error(`Geocoding failed for ${searchAddr}: ${data.info}`);
        })
        .catch(error => {
          console.error(`地理编码失败 for ${searchAddr}:`, error);
          throw error;
        });
    }

    // Draw the path on the map for a given record - 使用新的地理编码方式
    async function drawPath(tr, recordData) {
        try {
            // 使用城市+站点的组合进行地理编码
            const startCoords = await geocode(recordData.startStation, recordData.startCity);
            const endCoords = await geocode(recordData.endStation, recordData.endCity);
            
            // 为起终点相同的路线创建一个唯一的键，并计数
            const key = [recordData.startStation, recordData.endStation].sort().join('→');
            counts[key] = (counts[key] || 0) + 1;
            const pathIndex = counts[key] - 1;

            // 根据设置决定是否创建标记点
            let marker1, marker2;
            if (showMarkers) {
                marker1 = new AMap.Marker({ position: startCoords, map });
                marker2 = new AMap.Marker({ position: endCoords, map });
            }
            
            // 获取当前记录年份对应的颜色 - 从日期提取年份
            const year = recordData.date ? recordData.date.substring(0, 4) : new Date().getFullYear().toString();
            const strokeColor = getYearColor(year);
            
            // 生成贝塞尔弧线
            function generateArc(p1, p2, idx = 0) {
              const [x1, y1] = p1, [x2, y2] = p2;
              const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
              const dx = x2 - x1, dy = y2 - y1, len = Math.hypot(dx, dy);
              let ux = -dy / len, uy = dx / len;
              
              // 减小基础弧度系数，从0.35减小到0.15
              const base = 0.15 * len;
              const factor = base * (1 + idx * 0.15);
              if(idx % 2) { ux = -ux; uy = -uy; }
              
              // 使用更多的控制点
              const controlPoints = [];
              
              // 生成5个控制点，沿着垂直方向适度偏移
              for (let i = 0; i < 5; i++) {
                const t = (i + 1) / 6; // 控制点在线段上的相对位置 (1/6, 2/6, ..., 5/6)
                // 使用更加平滑的正弦函数，减小幅度
                const cx = x1 + dx * t + ux * factor * Math.sin(Math.PI * t) * 0.8;
                const cy = y1 + dy * t + uy * factor * Math.sin(Math.PI * t) * 0.8;
                controlPoints.push([cx, cy]);
              }
              
              const seg = 120; // 增加段数，从80增加到120，使曲线更平滑
              const path = [];
              
              // 六阶贝塞尔曲线 (起点 + 5个控制点 + 终点)
              for(let i = 0; i <= seg; i++) {
                const t = i / seg;
                
                // 使用六阶贝塞尔曲线公式
                // 参考De Casteljau算法实现高阶贝塞尔曲线
                let point = [0, 0];
                let binomialCoef = 1;
                
                // 起点
                point[0] += Math.pow(1-t, 6) * x1;
                point[1] += Math.pow(1-t, 6) * y1;
                
                // 5个控制点
                for (let j = 0; j < 5; j++) {
                  binomialCoef = binomialCoef * (6-j) / (j+1); // 计算二项式系数 C(6,j+1)
                  const factor = binomialCoef * Math.pow(t, j+1) * Math.pow(1-t, 5-j);
                  point[0] += factor * controlPoints[j][0];
                  point[1] += factor * controlPoints[j][1];
                }
                
                // 终点
                point[0] += Math.pow(t, 6) * x2;
                point[1] += Math.pow(t, 6) * y2;
                
                path.push(point);
              }
              
              return path;
            }
            
            // 生成路径并创建折线
            const path = generateArc(startCoords, endCoords, pathIndex);
            const polyline = new AMap.Polyline({
                path: path,
                isOutline: false,
                strokeColor: strokeColor, // 使用年份对应的颜色
                strokeWeight: 2,
                strokeOpacity: 0.9,
                strokeStyle: 'solid'
            });
            
            map.add(polyline);
            
            // 存储覆盖物，根据是否显示标记决定存储内容
            if (showMarkers) {
                tr._overlays = [marker1, marker2, polyline];
            } else {
                tr._overlays = [polyline];
            }
        } catch (error) {
            console.error('绘制路径失败:', error);
        }
    }

    // Add a record to the table and draw it on the map
    function addRecordToTable(recordData, insertAfterTr = null) {
      const tr = document.createElement('tr');
      const rpk = recordData.distance > 0 ? (recordData.cost / recordData.distance).toFixed(4) : '';
      tr.innerHTML = `
        <td></td> <!-- Seq # updated later -->
        <td>${recordData.date}</td>
        <td>${recordData.time}</td>
        <td>${recordData.duration}</td>
        <td>${recordData.trainNo}</td>
        <td>${recordData.startStation}</td>
        <td>${recordData.startCity}</td>
        <td>${recordData.endStation}</td>
        <td>${recordData.endCity}</td>
        <td>${recordData.seatClass}</td>
        <td>${recordData.trainType}</td>
        <td>${recordData.bureau}</td>
        <td>${recordData.cost.toFixed(2)}</td>
        <td>${recordData.distance}</td>
        <td>${rpk}</td>
        <td>${recordData.notes}</td>
        <td>
          <button class="gemini" title="获取目的地旅游攻略">✨</button>
          <button class="modify">修改</button>
          <button class="insert">插入</button>
          <button class="delete">删除</button>
        </td>
      `;
      tbody.appendChild(tr);
      attachRowEvents(tr);
      // 实时绘制路径，无论地图是否完全加载
      drawPath(tr, recordData);
      
      // 更新图例
      updateYearLegend();
      
      return tr;
    }

    // 新增：切换标记显示状态
    function toggleMarkers() {
        showMarkers = !showMarkers;
        markerToggle.textContent = showMarkers ? '隐藏地点标记' : '显示地点标记';
        
        // 更新按钮样式
        if (showMarkers) {
            markerToggle.classList.add('hide-markers');
        } else {
            markerToggle.classList.remove('hide-markers');
        }
        
        // 保存设置到localStorage
        localStorage.setItem('showMarkers', showMarkers);
        
        // 重新绘制所有路径
        redrawAllPaths();
    }

    // 新增：重新绘制所有路径
    async function redrawAllPaths() {
        // 清除现有的所有覆盖物
        Array.from(tbody.children).forEach(tr => {
            tr._overlays?.forEach(o => o.setMap(null));
            tr._overlays = [];
        });
        
        // 清空计数器
        Object.keys(counts).forEach(key => delete counts[key]);
        
        // 重新绘制所有路径
        const allRows = Array.from(tbody.children);
        for (let i = 0; i < allRows.length; i++) {
            const tr = allRows[i];
            const rec = records[i];
            if (rec && rec.startStation && rec.endStation) {
                try {
                    await drawPath(tr, rec);
                    // 只有在需要API调用时才延迟
                    const needsApi = !geocodeCache[rec.startStation] || !geocodeCache[rec.endStation];
                    if (needsApi) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (error) {
                    console.error('重绘路径失败:', error);
                }
            }
        }

        // 更新图例
        updateYearLegend();
    }

    // --- Gemini API Function ---
    async function getTravelGuide(city) {
        geminiModalTitle.textContent = `${city} 旅游攻略 ✨`;
        geminiResult.innerHTML = '<div class="spinner"></div>';
        geminiModalOverlay.style.display = 'flex';

        const prompt = `为中国的"${city}"市写一份简洁的旅游攻略，风格活泼有趣。请使用Markdown格式，包含：
1. 三个最值得去的景点，并附上一句吸引人的描述。
2. 三样必吃的当地特色美食。
3. 一条给游客的小贴士。`;
        
        let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
        const payload = { contents: chatHistory };
        const apiKey = "AIzaSyAoOKoSnfj4KceHi7xyzL_Xww-7iY3gAGI";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.statusText}`);
            }

            const result = await response.json();
            
            if (result.candidates && result.candidates.length > 0) {
                const markdownText = result.candidates[0].content.parts[0].text;
                // 使用 marked.js 渲染 Markdown
                geminiResult.innerHTML = marked.parse(markdownText);
            } else {
                throw new Error("未能从API获取有效回复。");
            }
        } catch (error) {
            console.error("Gemini API call failed:", error);
            geminiResult.textContent = `获取攻略失败，请稍后重试。\n错误: ${error.message}`;
        }
    }
    
    // --- Initial Load & Event Listeners ---

    // Set initial theme
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.body.classList.toggle('dark', savedTheme === 'dark');
    themeToggle.textContent = savedTheme === 'dark' ? '切换浅色模式' : '切换暗色模式';

    // 加载标记显示设置
    showMarkers = localStorage.getItem('showMarkers') === 'true';
    markerToggle.textContent = showMarkers ? '隐藏地点标记' : '显示地点标记';
    
    // 初始化按钮样式
    if (showMarkers) {
        markerToggle.classList.add('hide-markers');
    } else {
        markerToggle.classList.remove('hide-markers');
    }

    // Theme toggle listener
    themeToggle.addEventListener('click', () => {
      const isDark = document.body.classList.toggle('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      themeToggle.textContent = isDark ? '切换浅色模式' : '切换暗色模式';
      updateMapTheme();
    });

    // 标记切换监听器
    markerToggle.addEventListener('click', toggleMarkers);

    // 总结面板标签切换事件监听器
    document.querySelectorAll('.summary-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // 移除所有活动状态
        document.querySelectorAll('.summary-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.summary-content').forEach(c => c.classList.remove('active'));
        
        // 添加活动状态
        tab.classList.add('active');
        const tabName = tab.dataset.tab;
        document.getElementById(tabName + 'Summary').classList.add('active');
      });
    });

    // 年份选择器事件监听器
    yearSelect.addEventListener('change', (e) => {
      updateYearlySummary(e.target.value);
    });

    // Price calculation listeners
    costInput.addEventListener('input', updatePricePerKm);
    distanceInput.addEventListener('input', updatePricePerKm);

    // CSV导出事件监听 - 修复：添加缺失的事件监听器
    document.getElementById('exportCsvBtn').addEventListener('click', exportToCsv);

    // CSV导入事件监听
    document.getElementById('importCsvBtn').addEventListener('click', () => {
      document.getElementById('importCsvFile').click();
    });
    
    document.getElementById('importCsvFile').addEventListener('change', e => {
      if (e.target.files.length > 0) {
        importCsv(e.target.files[0]);
        e.target.value = ''; // 重置文件选择器
      }
    });
    
    // Main form submission logic
    addBtn.addEventListener('click', () => {
      const recordData = {
          date: document.getElementById('date').value,
          time: document.getElementById('time').value,
          duration: document.getElementById('duration').value,
          trainNo: document.getElementById('trainNo').value.trim(),
          startStation: document.getElementById('startStation').value.trim(),
          startCity: startCityInput.value.trim(),
          endStation: document.getElementById('endStation').value.trim(),
          endCity: endCityInput.value.trim(),
          seatClass: document.getElementById('seatClass').value.trim(),
          trainType: document.getElementById('trainType').value.trim(),
          bureau: document.getElementById('bureau').value.trim(),
          cost: parseFloat(costInput.value) || 0,
          distance: parseFloat(distanceInput.value) || 0,
          notes: document.getElementById('notes').value.trim()
      };

      if (!recordData.startStation || !recordData.endStation) {
          alert("起点和终点站不能为空！");
          return;
      }
      
      let newRow;
      if (currentMode === 'modify' && insertionTarget) {
          insertionTarget._overlays?.forEach(o => o.setMap(null));
          const insertBefore = insertionTarget.nextSibling;
          insertionTarget.remove();
          newRow = addRecordToTable(recordData);
          if (insertBefore) {
            tbody.insertBefore(newRow, insertBefore);
          } else {
            tbody.appendChild(newRow);
          }
      } else if (currentMode === 'insert' && insertionTarget) {
          addRecordToTable(recordData, insertionTarget);
      } else { // 'add' mode
          addRecordToTable(recordData);
      }

      updateSequenceNumbers();
      syncRecordsFromTable(); // Save all changes
      clearForm();
      setMode('add');
    });

    // Modal close listeners
    geminiModalClose.addEventListener('click', () => {
        geminiModalOverlay.style.display = 'none';
    });
    geminiModalOverlay.addEventListener('click', (e) => {
        if (e.target === geminiModalOverlay) {
            geminiModalOverlay.style.display = 'none';
        }
    });

    // 新增：CSV导入功能
    function importCsv(file) {
      if (!file) return;
      
      const reader = new FileReader();
      
      reader.onload = function(e) {
        try {
          const csvText = e.target.result;
          const lines = csvText.split('\n');
          
          if (lines.length <= 1) {
            throw new Error('CSV文件无数据或格式错误');
          }
          
          // 解析CSV头部
          const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
          console.log('CSV表头:', headers);
          
          // 解析CSV数据
          const csvData = [];
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const values = parseCsvLine(line);
            if (values.length === headers.length) {
              const rowData = {};
              headers.forEach((header, index) => {
                rowData[header] = values[index];
              });
              csvData.push(rowData);
            }
          }
          
          console.log('CSV数据预览:', csvData);
          
          // 解析CSV数据为应用格式
          const newRecords = parseCsvToRecords(csvData);
          
          if (newRecords.length === 0) {
            throw new Error('无法解析CSV数据，请检查文件格式');
          }
          
          // 询问用户如何处理数据
          const replace = confirm(
            `成功解析 ${newRecords.length} 条记录\n\n` +
            `点击"确定"替换所有现有数据\n` +
            `点击"取消"添加到现有数据`
          );
          
          if (replace) {
            records = newRecords;
          } else {
            records = [...records, ...newRecords];
          }
          
          saveRecords();
          alert(`${replace ? '替换' : '添加'}了 ${newRecords.length} 条记录，页面将重新加载`);
          location.reload();
          
        } catch (error) {
          console.error('CSV导入失败:', error);
          alert('CSV导入失败: ' + error.message);
        }
      };
      
      reader.onerror = function() {
        alert('读取CSV文件失败');
      };
      
      reader.readAsText(file, 'UTF-8');
    }

    // 解析CSV行，处理引号包围的字段
    function parseCsvLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      
      result.push(current.trim());
      return result;
    }

    // 解析CSV数据为记录格式
    function parseCsvToRecords(csvData) {
      const newRecords = [];
      
      // 字段映射
      const fieldMap = {
        seq: '序号',
        date: '时间',
        time: '时刻', 
        duration: '时长',
        trainNo: '车次',
        startStation: '起点',
        startCity: '起点城市',
        endStation: '终点',
        endCity: '终点城市',
        seatClass: '坐席',
        trainType: '车型号',
        bureau: '铁路局',
        cost: '费用(RMB)',
        distance: '里程(km)',
        pricePerKm: 'RMB/km',
        notes: '备注'
      };
      
      for (const row of csvData) {
        try {
          // 处理日期格式
          let date = '';
          if (row[fieldMap.date]) {
            const dateStr = String(row[fieldMap.date]);
            const match = dateStr.match(/(\d{4})[\.\-\/]?(\d{1,2})[\.\-\/]?(\d{1,2})/);
            if (match) {
              const [, y, m, d] = match;
              date = `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
            }
          }
          
          // 处理时间格式
          let time = '';
          if (row[fieldMap.time]) {
            const timeStr = String(row[fieldMap.time]).trim();
            const match = timeStr.match(/(\d{1,2})[\：\:\.]\s*(\d{1,2})/);
            if (match) {
              const [, h, m] = match;
              time = `${h.padStart(2, '0')}:${m.padStart(2, '0')}`;
            }
          }
          
          // 处理时长格式
          let duration = '';
          if (row[fieldMap.duration]) {
            const durationStr = String(row[fieldMap.duration]);
            const match = durationStr.match(/(\d{1,2})[\：\:](\d{1,2})/);
            if (match) {
              const [, h, m] = match;
              duration = `${h.padStart(2, '0')}:${m.padStart(2, '0')}`;
            }
          }
          
          const record = {
            date: date,
            time: time,
            duration: duration,
            trainNo: String(row[fieldMap.trainNo] || ''),
            startStation: String(row[fieldMap.startStation] || ''),
            startCity: String(row[fieldMap.startCity] || ''),
            endStation: String(row[fieldMap.endStation] || ''),
            endCity: String(row[fieldMap.endCity] || ''),
            seatClass: String(row[fieldMap.seatClass] || ''),
            trainType: String(row[fieldMap.trainType] || ''),
            bureau: String(row[fieldMap.bureau] || ''),
            cost: parseFloat(row[fieldMap.cost]) || 0,
            distance: parseFloat(row[fieldMap.distance]) || 0,
            notes: String(row[fieldMap.notes] || '')
          };
          
          // 验证必要字段
          if (!record.startStation || !record.endStation) {
            console.warn('跳过无效行，缺少起点或终点:', row);
            continue;
          }
          
          newRecords.push(record);
          
        } catch (error) {
          console.warn('解析CSV行数据失败:', row, error);
        }
      }
      
      return newRecords;
    }

    // CSV导入事件监听
    document.getElementById('importCsvBtn').addEventListener('click', () => {
      document.getElementById('importCsvFile').click();
    });
    
    document.getElementById('importCsvFile').addEventListener('change', e => {
      if (e.target.files.length > 0) {
        importCsv(e.target.files[0]);
        e.target.value = ''; // 重置文件选择器
      }
    });

    // 新增：CSV导出功能
    function exportToCsv() {
      try {
        if (records.length === 0) {
          alert('没有数据可以导出！');
          return;
        }

        // CSV表头
        const headers = [
          '序号', '时间', '时刻', '时长', '车次', '起点', '起点城市', 
          '终点', '终点城市', '坐席', '车型号', '铁路局', 
          '费用(RMB)', '里程(km)', 'RMB/km', '备注'
        ];

        // 构建CSV内容
        const csvContent = [];
        
        // 添加表头
        csvContent.push(headers.join(','));
        
        // 添加数据行
        records.forEach((record, index) => {
          const pricePerKm = record.distance > 0 ? (record.cost / record.distance).toFixed(4) : '';
          const row = [
            index + 1, // 序号
            record.date || '',
            record.time || '',
            record.duration || '',
            record.trainNo || '',
            record.startStation || '',
            record.startCity || '',
            record.endStation || '',
            record.endCity || '',
            record.seatClass || '',
            record.trainType || '',
            record.bureau || '',
            (record.cost || 0).toFixed(2),
            record.distance || 0,
            pricePerKm,
            record.notes || ''
          ];
          
          // 处理包含逗号的字段，用引号包围
          const escapedRow = row.map(field => {
            const fieldStr = String(field);
            if (fieldStr.includes(',') || fieldStr.includes('"') || fieldStr.includes('\n')) {
              return '"' + fieldStr.replace(/"/g, '""') + '"';
            }
            return fieldStr;
          });
          
          csvContent.push(escapedRow.join(','));
        });

        // 创建Blob对象
        const csvString = csvContent.join('\n');
        const blob = new Blob(['\uFEFF' + csvString], { type: 'text/csv;charset=utf-8;' });

        // 创建下载链接
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        
        // 生成文件名（包含当前日期）
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 10);
        link.setAttribute('download', `火车票记录_${dateStr}.csv`);
        
        // 触发下载
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert(`成功导出 ${records.length} 条记录到CSV文件！`);
        
      } catch (error) {
        console.error('CSV导出失败:', error);
        alert('CSV导出失败: ' + error.message);
      }
    }

    // Load records from localStorage on startup
    function initialLoad() {
        // 首先加载地理编码缓存
        loadGeocodeCache();
        
        const savedTheme = localStorage.getItem('theme') || 'light';
        map = new AMap.Map('container', {
          center: [106.712, 34.205],
          zoom: 5,
          mapStyle: savedTheme === 'dark' ? DARK_MAP_STYLE : LIGHT_MAP_STYLE,
        });

        // 从localStorage加载记录
        records = JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
        
        // 先清空表格
        tbody.innerHTML = '';
        
        // 添加记录到表格（不绘制地图）
        records.forEach(rec => {
          const tr = document.createElement('tr');
          const rpk = rec.distance > 0 ? (rec.cost / rec.distance).toFixed(4) : '';
          tr.innerHTML = `
            <td></td> <!-- Seq # updated later -->
            <td>${rec.date || ''}</td>
            <td>${rec.time || ''}</td>
            <td>${rec.duration || ''}</td>
            <td>${rec.trainNo || ''}</td>
            <td>${rec.startStation || ''}</td>
            <td>${rec.startCity || ''}</td>
            <td>${rec.endStation || ''}</td>
            <td>${rec.endCity || ''}</td>
            <td>${rec.seatClass || ''}</td>
            <td>${rec.trainType || ''}</td>
            <td>${rec.bureau || ''}</td>
            <td>${(rec.cost || 0).toFixed(2)}</td>
            <td>${rec.distance || 0}</td>
            <td>${rpk}</td>
            <td>${rec.notes || ''}</td>
            <td>
              <button class="gemini" title="获取目的地旅游攻略">✨</button>
              <button class="modify">修改</button>
              <button class="insert">插入</button>
              <button class="delete">删除</button>
            </td>
          `;
          tbody.appendChild(tr);
          attachRowEvents(tr);
        });
        
        updateSequenceNumbers();
        
        // 初始化总结面板和图表
        updateSummaryPanels();

        // 地图完全加载后绘制所有路径
        map.on('complete', async function() {
          // 清空计数器
          Object.keys(counts).forEach(key => delete counts[key]);
          
          // 检查是否所有站点都已缓存
          const missingStations = new Set();
          records.forEach(rec => {
            const startKey = (rec.startCity || '') + (rec.startStation || '') + '站';
            const endKey = (rec.endCity || '') + (rec.endStation || '') + '站';
            if (rec.startStation && !geocodeCache[startKey]) {
              missingStations.add(startKey);
            }
            if (rec.endStation && !geocodeCache[endKey]) {
              missingStations.add(endKey);
            }
          });
          
          console.log(`缓存状态: 总站点 ${Object.keys(geocodeCache).length} 个，需要查询 ${missingStations.size} 个新站点`);
          
          // 获取所有表格行并绘制对应的路径
          const allRows = Array.from(tbody.children);
          let successCount = 0;
          let failCount = 0;
          
          for (let i = 0; i < allRows.length; i++) {
            const tr = allRows[i];
            const rec = records[i];
            if (rec && rec.startStation && rec.endStation) {
              try {
                await drawPath(tr, rec);
                successCount++;
                console.log(`成功绘制路径 ${i + 1}/${allRows.length}: ${rec.startStation} → ${rec.endStation}`);
                
                // 只有在需要API调用时才延迟
                const startKey = (rec.startCity || '') + (rec.startStation || '') + '站';
                const endKey = (rec.endCity || '') + (rec.endStation || '') + '站';
                const needsApi = !geocodeCache[startKey] || !geocodeCache[endKey];
                if (needsApi) {
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              } catch (error) {
                failCount++;
                console.error(`绘制路径失败 ${i + 1}/${allRows.length}:`, rec.startStation, '→', rec.endStation, error.message);
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }
          }
          
          console.log(`路径绘制完成: 成功 ${successCount}, 失败 ${failCount}`);
          if (failCount > 0) {
            console.warn('部分路径绘制失败，可能是由于API配额限制。大部分站点坐标已缓存，后续刷新会更快。');
          }
          
          // 绘制完成后更新图例
          updateYearLegend();
        });

        clearForm();
    }

    window.onload = initialLoad;

  </script>
</body>
</html>
